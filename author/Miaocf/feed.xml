<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="http://www.w3.org/2005/Atom" >
  <generator uri="https://jekyllrb.com/" version="3.7.4">Jekyll</generator>
  <link href="http://localhost:4000/author/Miaocf/feed.xml" rel="self" type="application/atom+xml" />
  <link href="http://localhost:4000/" rel="alternate" type="text/html" />
  <updated>2019-10-10T16:50:54+08:00</updated>
  <id>http://localhost:4000/author/Miaocf/feed.xml</id>

  
  
  

  
    <title type="html">Miaocf | </title>
  

  
    <subtitle>Cloud in the sky, fish in the river</subtitle>
  

  

  
    
      
    
  

  
  

  
    <entry>
      <title type="html">Building Objective-C static libraries with categories</title>
      <link href="http://localhost:4000/yykit-micro" rel="alternate" type="text/html" title="Building Objective-C static libraries with categories" />
      <published>2019-09-25T02:00:00+08:00</published>
      <updated>2019-09-25T02:00:00+08:00</updated>
      <id>http://localhost:4000/yykit-micro</id>
      <content type="html" xml:base="http://localhost:4000/yykit-micro">&lt;blockquote&gt;
  &lt;p&gt;Q:  How do I fix “selector not recognized” runtime exceptions when trying to use category methods from a static library?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如何解决 在 runtime 环境中尝试调用静态库中分类的方法时，报 “selector not recognized” 异常？&lt;/p&gt;

&lt;p&gt;  今天在浏览 YYKit 库时，一个宏定义引起了我的注意：&lt;code class=&quot;highlighter-rouge&quot;&gt;YYSYNTH_DUMMY_CLASS &lt;/code&gt;,从字面意思看是定义了一个不起任何作用的&lt;em&gt;哑&lt;/em&gt;类。相关描述如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Objective-C&quot;&gt;/**
 Add this macro before each category implementation, so we don't have to use
 -all_load or -force_load to load object files from static libraries that only
 contain categories and no classes.
 More info: http://developer.apple.com/library/mac/#qa/qa2006/qa1490.html .
 *******************************************************************************
 Example:
     YYSYNTH_DUMMY_CLASS(NSString_YYAdd)
 */
#ifndef YYSYNTH_DUMMY_CLASS
#define YYSYNTH_DUMMY_CLASS(_name_) \
@interface YYSYNTH_DUMMY_CLASS_ ## _name_ : NSObject @end \
@implementation YYSYNTH_DUMMY_CLASS_ ## _name_ @end
#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  根据 YYKit 作者的描述，在分类中加一个这样的宏定义可以避免一些复杂操作，具体原理作者并没有解释，只是给了一个苹果官方开发文档的连接。这个链接可能因为官方整理文档的原因，URL路径已经失效了。但是在官网搜索 URL 中的关键字找到了这篇&lt;a href=&quot;https://developer.apple.com/library/archive/qa/qa1490/_index.html&quot;&gt;资料&lt;/a&gt;。根据这篇资料在这里深入了解一下其中的原理和如何解决这类问题。&lt;/p&gt;

&lt;p&gt;官方文档以一个问题开篇，就是上面提出的那个问题，哈哈。接下来官方文档就给出了问题的解决方法：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;A: If you’re seeing a “selector not recognized” runtime exception when calling a category method that is implemented in a static library, you are hitting the link-time build issue described here, and need to add the -ObjC linker flag to your project, by following these steps:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;In Xcode, choose View &amp;gt; Navigators &amp;gt; Show Project Navigator, or press ⌘1.&lt;/li&gt;
    &lt;li&gt;Select your project under the PROJECT heading in the Project Navigator, then select the Build Settings tab.&lt;/li&gt;
    &lt;li&gt;Scroll down to the Other Linker Flags build setting under the Linking collection, or type “Other Linker Flags” into the search bar.&lt;/li&gt;
    &lt;li&gt;Set the value of the Other Linker Flags build setting to $(OTHER_LDFLAGS) -ObjC.&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;译：当你在运行时调用一个在静态库中实现的分类的方法时，遇到 “selector not recognized” 运行时异常，那么你就撞到了本篇文档中描述的所谓的 “the link-time build issue” 问题，同时你需要在你的工程中加上 &lt;code class=&quot;highlighter-rouge&quot;&gt;-ObjC linker flag&lt;/code&gt; 来解决这个问题。具体步骤：(在这里就不翻译了么么哒)。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Figure 1:&lt;/em&gt;  Modifying the Other Linker Flags build setting.    &lt;br /&gt;
&lt;br /&gt;&lt;img src=&quot;../assets/article_assets/qa1490_other_linker_flags_xcode_5.png&quot; /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;h3 id=&quot;troubleshooting&quot;&gt;Troubleshooting&lt;/h3&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;If adding the -ObjC flag isn’t fixing the problem, double check that a conflicting Target build setting is not overriding it, by following the above steps, but selecting the current target under “TARGETS” in step 2, instead of the project.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;解决问题&quot;&gt;解决问题&lt;/h3&gt;
&lt;p&gt;  如果添加&lt;code class=&quot;highlighter-rouge&quot;&gt;-ObjC flag&lt;/code&gt;没能解决这个问题，检查一下确保之前的操作没有与 Target build setting 冲突而使其无效。按照上面的步骤，在第二步时选择 &lt;em&gt;“TARGETS”&lt;/em&gt;下的target，而不是选择 project。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;h3 id=&quot;other-causes-of-selector-not-recognized-exceptions&quot;&gt;Other Causes of selector not recognized Exceptions&lt;/h3&gt;
  &lt;p&gt;The most common causes of a “selector not recognized” exception are:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;h3 id=&quot;no-such-method&quot;&gt;No Such Method&lt;/h3&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;The method really does not exist. Check your spelling. Check documentation to verify that the method exists on the version of the operating system your app is using.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;h3 id=&quot;memory-management&quot;&gt;Memory Management&lt;/h3&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Your app is trying to use an object after it has been deallocated, use the Zombies instrument to debug this kind of problem. You are seeing “selector not recognized” because the memory has been re-allocated as a different kind of object.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;导致selector-not-recognized-exceptions异常的其他原因&quot;&gt;导致&lt;code class=&quot;highlighter-rouge&quot;&gt;selector not recognized Exceptions&lt;/code&gt;异常的其他原因&lt;/h3&gt;
&lt;p&gt;  导致&lt;code class=&quot;highlighter-rouge&quot;&gt;selector not recognized Exceptions&lt;/code&gt;异常的原因通常是：&lt;/p&gt;
&lt;h4 id=&quot;方法不存在&quot;&gt;方法不存在&lt;/h4&gt;
&lt;p&gt;  方法实际上是不存在的。检查你的拼写是否有误。查阅文档，确保你调用的方法在当前版本的操作系统内存在。&lt;/p&gt;
&lt;h4 id=&quot;内存管理&quot;&gt;内存管理&lt;/h4&gt;
&lt;p&gt;  在对象已释放后，你的应用又尝试去访问它，原先存放对象的内存已被重新分配给其他类的对象，所以当你再次访问原先的对象时，就会发生 “selector not recognized”异常。使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Zombies instrument&lt;/code&gt;工具来debug这类问题。（这一段文档不通顺，稍作整理）&lt;/p&gt;

&lt;blockquote&gt;
  &lt;h2 id=&quot;what-causes-those-exceptions&quot;&gt;What causes those exceptions?&lt;/h2&gt;
  &lt;p&gt;An impedance mismatch between UNIX static libraries and the dynamic nature of Objective-C can cause category methods in static libraries to not be linked into an app, resulting in “selector not recognized” exceptions when the methods aren’t found at runtime.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;导致这些异常的原因&quot;&gt;导致这些异常的原因&lt;/h2&gt;
&lt;p&gt;由于 &lt;code class=&quot;highlighter-rouge&quot;&gt;UNIX static libraries&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;dynamic nature of Objective-C&lt;/code&gt;不是很搭的原因，导致静态库中分类的方法不会被链接到app中去，以至于在 runtime 动态调用时无法找到方法，结果发生 “selector not recognized”异常。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;h3 id=&quot;the-linker&quot;&gt;The Linker&lt;/h3&gt;
  &lt;p&gt;When a C program is compiled, each “source file” is turned into an “object file” that contains executable functions and static data. The linker glues these object files together into a final executable. That executable is eventually bundled into an app by Xcode.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;链接器&quot;&gt;链接器&lt;/h3&gt;
&lt;p&gt;当一个 C 程序被编译完成，所有”原文件”都被转换为”object file”，这些”object file”包含可执行方法和静态数据。链接器将这些”object file”粘合在一起，最终成为可执行文件。最终 Xcode 将这些可执行文件打包进APP中。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;When a source file uses something (like a function) defined in another file, then an undefined symbol is written into the object file, to “stand in” for the missing thing. The linker resolves these symbols by pulling in the object files that include definitions of undefined symbols when building the final executable.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;当一个原文件调用某些在其他文件中定义的方法或者数据时，那么一个&lt;code class=&quot;highlighter-rouge&quot;&gt;未经定义的符号&lt;/code&gt;就被写入了 “object file”,用以代替缺失的方法或数据。在组成最终可执行文件时，链接器从那些包含 “undefined symbols” 定义的 “object files” 中抽取定义来解析这些符号。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;For example, if main.c uses the function foo(), where foo is defined in another file, B.c, then the object file main.o will have an unresolved symbol for foo(), and B.o will include an implementation of foo(). At link time, B.o will be brought into the final executable, so that the code in main.o now references the implementation of foo() defined in B.o.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;举个例子，假如 &lt;code class=&quot;highlighter-rouge&quot;&gt;main.c&lt;/code&gt; 调用方法 &lt;code class=&quot;highlighter-rouge&quot;&gt;foo()&lt;/code&gt;,而 &lt;code class=&quot;highlighter-rouge&quot;&gt;foo&lt;/code&gt; 函数是在另一个文件 &lt;code class=&quot;highlighter-rouge&quot;&gt;B.c&lt;/code&gt; 中定义的，那么 &lt;code class=&quot;highlighter-rouge&quot;&gt;object file main.o&lt;/code&gt; 将会有一个未解析符号表示 &lt;code class=&quot;highlighter-rouge&quot;&gt;foo()&lt;/code&gt;，同时 &lt;code class=&quot;highlighter-rouge&quot;&gt;B.o&lt;/code&gt; 将会包含 &lt;code class=&quot;highlighter-rouge&quot;&gt;foo()&lt;/code&gt; 方法实现。在链接阶段，&lt;code class=&quot;highlighter-rouge&quot;&gt;B.o&lt;/code&gt; 将会被带入 最终执行文件，因此现在 &lt;code class=&quot;highlighter-rouge&quot;&gt;main.o&lt;/code&gt; 中的代码就可以引用在 &lt;code class=&quot;highlighter-rouge&quot;&gt;B.o&lt;/code&gt; 中对 &lt;code class=&quot;highlighter-rouge&quot;&gt;foo()&lt;/code&gt; 的实现。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;A UNIX static library is just a collection of object files. Normally the linker only pulls in an object file from a static library if doing so would resolve some undefined symbol. Not pulling in all object files reduces the size of the final executable.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;UNIX static library&lt;/code&gt; 只是将 &lt;code class=&quot;highlighter-rouge&quot;&gt;object files&lt;/code&gt; 集合在一起。链接器通常只会从&lt;code class=&quot;highlighter-rouge&quot;&gt;static library&lt;/code&gt;中提取那些包含&lt;code class=&quot;highlighter-rouge&quot;&gt;undefined symbol&lt;/code&gt;解析的 object file，而不是把所有 &lt;code class=&quot;highlighter-rouge&quot;&gt;object files&lt;/code&gt; 都集成进来。这样可以减小最终可执行文件的体积。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;h3 id=&quot;objective-c&quot;&gt;Objective-C&lt;/h3&gt;
  &lt;p&gt;The dynamic nature of Objective-C complicates things slightly. Because the code that implements a method is not determined until the method is actually called, Objective-C does not define linker symbols for methods. Linker symbols are only defined for classes.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;objective-c-1&quot;&gt;Objective-C&lt;/h3&gt;

&lt;p&gt;O-C 的动态特性使这个过程略微复杂了一些。因为实现一个方法的代码直到这个方法被调用时才会被确定下来。Objective-C 并不为方法定义链接符号，链接符号只为 &lt;em&gt;类&lt;/em&gt; 进行定义。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;For example, if main.m includes the code [[FooClass alloc] initWithBar:nil]; then main.o will contain an undefined symbol for FooClass, but no linker symbols for the -initWithBar: method will be in main.o.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;比如： 假如 main.m 包含了这样的代码：&lt;code class=&quot;highlighter-rouge&quot;&gt;[[FooClass alloc] initWithBar:nil];&lt;/code&gt;,那么 &lt;code class=&quot;highlighter-rouge&quot;&gt;main.o&lt;/code&gt; 将会包含一个未定义符号表示 &lt;code class=&quot;highlighter-rouge&quot;&gt;FooClass&lt;/code&gt;，但是在 &lt;code class=&quot;highlighter-rouge&quot;&gt;main.o&lt;/code&gt; 文件中，并不生成链接符号去表示 &lt;code class=&quot;highlighter-rouge&quot;&gt;-initWithBar:&lt;/code&gt; 方法。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Since categories are a collection of methods, using a category’s method does not generate an undefined symbol. This means the linker does not know to load an object file defining the category, if the class itself is already defined. This causes the same “selector not recognized” runtime exception you would see for any unimplemented method.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;因为分类是一组方法的集合，假如一个类已经定义了，在其中使用分类的方法并不生成 &lt;code class=&quot;highlighter-rouge&quot;&gt;undefined symbol&lt;/code&gt;,这意味着链接器不知道需要去加载对应的 &lt;code class=&quot;highlighter-rouge&quot;&gt;object file&lt;/code&gt; 去定义分类。调用任何未实现的方法也一样会导致 “selector not recognized” 运行时异常。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;###The -ObjC Linker Flag
Passing the -ObjC option to the linker causes it to load all members of static libraries that implement any Objective-C class or category. This will pickup any category method implementations. But it can make the resulting executable larger, and may pickup unnecessary objects. For this reason it is not on by default.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;the--objc-linker-flag&quot;&gt;The -ObjC Linker Flag&lt;/h3&gt;
&lt;p&gt;指定 链接器的 &lt;code class=&quot;highlighter-rouge&quot;&gt;-ObjC&lt;/code&gt; 选项 可以使 链接器加载所有静态库总的成员，包括 &lt;code class=&quot;highlighter-rouge&quot;&gt;Objective-C&lt;/code&gt; 的类和分类。这将选入所有分类方法的实现。同时也使最最终的可执行文件体积更大，这也是为什么不作为默认选项。&lt;/p&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;YYKit 中的这个宏定义在 分类之前加了一个空类，这样&lt;code class=&quot;highlighter-rouge&quot;&gt;.m&lt;/code&gt;文件就包含了类，这样生成的 &lt;code class=&quot;highlighter-rouge&quot;&gt;.o&lt;/code&gt;文件就会被链接器打包进最终的可执行文件，从而避免了 “selector not recognized”异常的出现。&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Miaocf</name>
        
        
      </author>

      

      
        <category term="iOS" />
      

      
        <summary type="html">Q: How do I fix “selector not recognized” runtime exceptions when trying to use category methods from a static library?</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">UITextField 随键盘高度自适应</title>
      <link href="http://localhost:4000/textfield-height-auto-adjust" rel="alternate" type="text/html" title="UITextField 随键盘高度自适应" />
      <published>2019-09-23T22:00:00+08:00</published>
      <updated>2019-09-23T22:00:00+08:00</updated>
      <id>http://localhost:4000/textfield-height-auto-adjust</id>
      <content type="html" xml:base="http://localhost:4000/textfield-height-auto-adjust">&lt;p&gt;  在开发APP过程中，不免会遇到页面需要多个 UITextField 的需求，那么问题来了：当输入框过多时，弹起键盘会遮盖住输入框，或者需要依次点击输入框才能输入。用户的输入体验非常差。为解决这个问题，我们让输入框跟随键盘自动调整高度，并且点击回车键自动跳转到下一个输入框进行输入。&lt;/p&gt;

&lt;p&gt;具体效果如图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../assets/images/auto-adjust-height-textfield/auto-adjust-height-textfield.gif&quot; /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;需求分析&quot;&gt;需求分析：&lt;/h3&gt;
&lt;p&gt;  简单分析一下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;点击输入框时，输入框随着键盘弹起，自动调整高度，使输入框位于键盘上方。&lt;/li&gt;
  &lt;li&gt;点击回车，自动切换到下一个输入框进行输入，同时调整输入框高度。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;为了使输入框能够上下滑动，这里将所有 UITextField 放在一个 scrollview 上，然后添加键盘监听事件，当用户点击输入框时，触发键盘弹起，此时调整scrollView 的 contentOffset，使输入框正好位于键盘上方。&lt;/p&gt;

&lt;h4 id=&quot;添加键盘监听&quot;&gt;添加键盘监听：&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; [[NSNotificationCenter defaultCenter]addObserver:self selector:@selector(keyboardWillShow:) name:UIKeyboardWillShowNotification object:nil];
 [[NSNotificationCenter defaultCenter]addObserver:self selector:@selector(keyboardWillHide:) name:UIKeyboardWillHideNotification object:nil];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;键盘响应事件&quot;&gt;键盘响应事件：&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; - (void)keyboardWillShow:(NSNotification *)notification {
    //获取键盘高度，在不同设备上，以及中英文下是不同的
    CGFloat kbHeight = [[notification.userInfo objectForKey:UIKeyboardFrameEndUserInfoKey] CGRectValue].size.height;
    _keyBoardHeight = kbHeight;
    [self boardAutoAdjust:kbHeight];
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; - (void)keyboardWillHide:(NSNotification *)notify {
    // 键盘动画时间
    _keyBoardHeight = 0;
    [self.board setContentOffset:CGPointMake(0,-64) animated:YES];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;uitextfield-代理事件&quot;&gt;UITextField 代理事件：&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; - (BOOL)textFieldShouldBeginEditing:(UITextField *)textField {
    
    NSLog(@&quot;=== %@&quot;, [NSValue valueWithCGRect:textField.frame]);
    self.fistField = textField;
    
    if (_keyBoardHeight &amp;gt; 0) {
        [self boardAutoAdjust:_keyBoardHeight];
    }
    return YES;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;scrollview-偏移量计算&quot;&gt;scrollview 偏移量计算&lt;/h4&gt;
&lt;p&gt;  scrollView 需要偏移的量 =&lt;code class=&quot;highlighter-rouge&quot;&gt;页面总高度&lt;/code&gt; - &lt;code class=&quot;highlighter-rouge&quot;&gt;输入框高度&lt;/code&gt; - &lt;code class=&quot;highlighter-rouge&quot;&gt;键盘高度&lt;/code&gt;,当输入框高于键盘时，偏移量小于零，反之，偏移量大于零。 
&lt;br /&gt;
&lt;img width=&quot;200&quot; src=&quot;../assets/images/auto-adjust-height-textfield/mark-line.png&quot; /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;偏移量计算方法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)boardAutoAdjust:(CGFloat)keyboardHeight {
    
    if (self.fistField) {
        
        CGRect rec = _fistField.frame;
        
        CGFloat max_y = CGRectGetMaxY(rec);
        
        CGFloat b_offset = self.view.height - max_y - keyboardHeight;
        
        CGPoint point = self.board.contentOffset;
        point.y = -b_offset;
        
        [self.board setContentOffset:point animated:YES];
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;键盘回车事件&quot;&gt;键盘回车事件&lt;/h4&gt;

&lt;p&gt;  当点击键盘回车时，自动跳转到下一个输入框进行输入，最后一个输入框点击回车时，收起键盘，整体回到原先的布局高度。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (BOOL)textFieldShouldReturn:(UITextField *)textField {
    
    if (textField.returnKeyType == UIReturnKeyNext) {
        
        [textField resignFirstResponder];
        UITextField *next = [self.textfields objectAtIndex:(textField.tag + 1)];
        [next becomeFirstResponder];
        
    } else if (textField.returnKeyType == UIReturnKeyDone) {
        
        [textField resignFirstResponder];
    }
    
    return YES;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/JumpJumpSparrow/DemoCollection.git&quot;&gt;demo链接&lt;/a&gt;&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Miaocf</name>
        
        
      </author>

      

      
        <category term="iOS" />
      

      
        <summary type="html">  在开发APP过程中，不免会遇到页面需要多个 UITextField 的需求，那么问题来了：当输入框过多时，弹起键盘会遮盖住输入框，或者需要依次点击输入框才能输入。用户的输入体验非常差。为解决这个问题，我们让输入框跟随键盘自动调整高度，并且点击回车键自动跳转到下一个输入框进行输入。</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">使用 shell 脚本配置iOS工程生成多个APP</title>
      <link href="http://localhost:4000/script-configure" rel="alternate" type="text/html" title="使用 shell 脚本配置iOS工程生成多个APP" />
      <published>2019-09-20T07:00:00+08:00</published>
      <updated>2019-09-20T07:00:00+08:00</updated>
      <id>http://localhost:4000/script-configure</id>
      <content type="html" xml:base="http://localhost:4000/script-configure">&lt;p&gt;  APP开发过程中，往往需要在多个网络环境或配置中进行切换，以获取不同配置的APP，甚至有时需要用一套代码经过简单的配置生成不同的APP。而手动配置费时费力，且容易出错。这里介绍用脚本工具，去生成不同配置的APP工程。&lt;/p&gt;

&lt;h3 id=&quot;1-需求分析&quot;&gt;1. 需求分析&lt;/h3&gt;

&lt;p&gt;在配置工程中我们需要事先知道有哪些配置项：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;APP 启动图、图标等资源文件。&lt;/li&gt;
  &lt;li&gt;APP 名称、版本号、bundleID。&lt;/li&gt;
  &lt;li&gt;APP 相关的微信 APPKey、scheme。&lt;/li&gt;
  &lt;li&gt;网络环境、部分代码替换。&lt;/li&gt;
  &lt;li&gt;provisioning profile 修改&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;分析以上需要配置的项，我们可以发现这些配置项可以分为&lt;strong&gt;三类&lt;/strong&gt;，分别是：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;资源文件替换&lt;/li&gt;
  &lt;li&gt;plist 字段修改&lt;/li&gt;
  &lt;li&gt;部分代码替换&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;接下来介绍如何实现满足以上需求的Shell脚本。&lt;/p&gt;

&lt;h3 id=&quot;2-脚本设计实现&quot;&gt;2. 脚本设计&amp;amp;实现&lt;/h3&gt;

&lt;h4 id=&quot;21-创建脚本&quot;&gt;2.1 创建脚本&lt;/h4&gt;

&lt;p&gt;  首先创建一个shell脚本文件，在命令行工具中输入&lt;code class=&quot;highlighter-rouge&quot;&gt;touch xxx.sh&lt;/code&gt;就可以创建shell脚本文件,在这里将shell脚本命名为：&lt;code class=&quot;highlighter-rouge&quot;&gt;projectDeploy.sh&lt;/code&gt;。&lt;br /&gt;
  运行脚本时在命令行工具中切换到脚本文件所在的路径，输入:&lt;code class=&quot;highlighter-rouge&quot;&gt;sh projectDeploy.sh&lt;/code&gt;命令就可以运行脚本了。&lt;/p&gt;
&lt;h4 id=&quot;22-脚本传参&quot;&gt;2.2 脚本传参&lt;/h4&gt;
&lt;p&gt;我们需要传入参数告诉脚需要的具体配置,shell 脚本传入参数的方式有多种，这里只介绍一种：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;while getopts &quot;:e:s:&quot; opt

do
    case $opt in
        e)
            environment=$OPTARG;;

        s)
            supplier=$OPTARG;;

        ?)
            echo &quot;请输入正确的参数&quot;
            exit 1;;
    esac
done

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这里定义了两个全局变量 &lt;code class=&quot;highlighter-rouge&quot;&gt;environment&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;supplier&lt;/code&gt;，当调用脚本时，输入命令 &lt;code class=&quot;highlighter-rouge&quot;&gt;sh projectDeploy.sh -e prd -s xxx&lt;/code&gt;&lt;br /&gt;
这种传参的好处是，指定了具体变量对应的值，不必保持参数的顺序。&lt;/p&gt;

&lt;h4 id=&quot;23-资源替换&quot;&gt;2.3 资源替换&lt;/h4&gt;

&lt;p&gt;  资源替换这里使用了shell脚本里的 &lt;code class=&quot;highlighter-rouge&quot;&gt;copy&lt;/code&gt; 命令：
&lt;code class=&quot;highlighter-rouge&quot;&gt;cp source_file_directory destination_directory&lt;/code&gt;。&lt;br /&gt;
将要替换的资源文件复制到指定位置，有时需要事先将路径下的文件清理一下再进行copy 操作：
&lt;code class=&quot;highlighter-rouge&quot;&gt;rm -rf destination_directory&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;  如果有同名文件存在，copy操作会覆盖原文件。&lt;br /&gt;
  这一操作可以用来替换启动图、桌面图标、图片资源、SDK、代码文件等文件类替换需求。&lt;/p&gt;

&lt;h4 id=&quot;24-plist-字段修改&quot;&gt;2.4 plist 字段修改&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;APP桌面名称&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;版本号&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;bundleID&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;scheme&lt;/code&gt;等等plist 内的值需要替换，&lt;br /&gt;
这里我们使用 MAC 自带的plist 文件编辑工具 &lt;code class=&quot;highlighter-rouge&quot;&gt;PlistBuddy&lt;/code&gt; 来实现plist文件的维护，
这个工具的访问路径为：&lt;code class=&quot;highlighter-rouge&quot;&gt;/usr/libexec/PlistBuddy&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;具体命令为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/usr/libexec/PlistBuddy -c &quot;set CFBundleIdentifier com.xxx.xxx&quot; ${project_infoplist_path}  
/usr/libexec/PlistBuddy -c &quot;set CFBundleShortVersionString ${appVersion}&quot; ${project_infoplist_path}
/usr/libexec/PlistBuddy -c &quot;set CFBundleDisplayName xxx&quot; ${project_infoplist_path}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;em&gt;scheme 值修改&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;  因为 scheme 的数据结构为 数组元素可能是字典，字典key对应的value可能是数组，因此需要事先知道要修改的值的数据结构和位置，在使用 plist 工具时指定字典对应的key，数组对应的下标：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/usr/libexec/PlistBuddy -c &quot;set CFBundleURLTypes:0:CFBundleURLSchemes:0 xxx.xxx.xxx&quot; ${project_infoplist_path}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;  以上命令的意思是取 &lt;code class=&quot;highlighter-rouge&quot;&gt;CFBundleURLTypes&lt;/code&gt; 数组下的第一个元素 X，再取 X 下 &lt;code class=&quot;highlighter-rouge&quot;&gt;CFBundleURLSchemes&lt;/code&gt; 数组下的第一个元素 Y，并更新Y的值为&lt;code class=&quot;highlighter-rouge&quot;&gt;xxx.xxx.xxx&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;  至于 provisioning profile 的替换，只需要在打包脚本里去指定就可以了，至于&lt;code class=&quot;highlighter-rouge&quot;&gt;project.pbxproj&lt;/code&gt;文件的一些配置，也可以用 2.5 的方法去配置，见下一部分。&lt;/p&gt;

&lt;h4 id=&quot;25-部分代码替换&quot;&gt;2.5 部分代码替换&lt;/h4&gt;

&lt;p&gt;  假如需要修改代码里的部分字符，或批量修改某个变量名称，这里就用到了 &lt;code class=&quot;highlighter-rouge&quot;&gt;sed&lt;/code&gt; 命令.
这里讲一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;sed &lt;/code&gt;命令的用法，如果有其他特殊需求，可查询sed 命令的其他用法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sed -i '' 's/^\#define XXX_XX_URL.*$/\#define XXX_XX_URL  @\&quot;www.junziboxue.com\&quot;/g' ${configureFile}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;  这个命令的意思是，匹配所有 &lt;code class=&quot;highlighter-rouge&quot;&gt;#define XXX_XX_URL&lt;/code&gt; 宏，然后替换为 &lt;code class=&quot;highlighter-rouge&quot;&gt;#define XXX_XX_URL  @&quot;www.junziboxue.com&quot;&lt;/code&gt;，这里是整行替换。shell 命令里需要对一些特殊字符进行转义，在这里需要注意。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;^\#define XXX_XX_URL.*$&lt;/code&gt;&lt;/em&gt; 是一个正则表达式，表示所有 以 &lt;code class=&quot;highlighter-rouge&quot;&gt;#define XXX_XX_URL&lt;/code&gt; 开头的字符，&lt;code class=&quot;highlighter-rouge&quot;&gt;/g&lt;/code&gt;表示全局替换。
具体 sed 的其他用法可自行查询。&lt;/p&gt;

&lt;h3 id=&quot;3-总结&quot;&gt;3 总结&lt;/h3&gt;

&lt;p&gt;  在掌握以上方法后，我们基本可以任意配置一份代码工程，修改其一些APP的基本配置。
假如要配置的项很多，可能导致脚本非常臃肿，面对这样的情况，我们需要设计一下脚本的结构：&lt;br /&gt;
  我们可以把要配置的项剥离出来，然后设计一个函数执行具体配置，然后在函数内传入参数去指定具体的配置。
或者将配置项事先写好，然后让函数取读就可以了。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/JumpJumpSparrow/deploy_project_with_shell_script.git&quot;&gt;script_demo&lt;/a&gt;&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Miaocf</name>
        
        
      </author>

      

      
        <category term="iOS" />
      

      
        <summary type="html">  APP开发过程中，往往需要在多个网络环境或配置中进行切换，以获取不同配置的APP，甚至有时需要用一套代码经过简单的配置生成不同的APP。而手动配置费时费力，且容易出错。这里介绍用脚本工具，去生成不同配置的APP工程。</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">iOS 圆角+阴影+离屏渲染问题</title>
      <link href="http://localhost:4000/ios-shadow-roundcorner-offscreen" rel="alternate" type="text/html" title="iOS 圆角+阴影+离屏渲染问题" />
      <published>2019-09-16T18:00:00+08:00</published>
      <updated>2019-09-16T18:00:00+08:00</updated>
      <id>http://localhost:4000/ios-shadow-roundcorner-offscreen</id>
      <content type="html" xml:base="http://localhost:4000/ios-shadow-roundcorner-offscreen">&lt;p&gt;iOS 圆角+阴影+离屏渲染问题&lt;/p&gt;

&lt;p&gt;在近一期开发需求中，有个控件需要同时添加圆角和阴影效果。本以为是个非常简单的需求，但开发过程并不十分美丽。今天就整理一下控件添加圆角和阴影一些需要注意的地方。&lt;/p&gt;

&lt;p&gt;为什么给一个控件同时添加 阴影和圆角这么困难呢？一句话解释就是：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;Because shadow is an effect done outside the View, and that masksToBounds set to YES will tell the UIView not to draw everything that is outside itself.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;简单来说就是：阴影效果是展示在 View 外的，而切圆角要求不显示 View 外部的内容。显然，圆角和阴影要同时显示本身就是矛盾的。&lt;/p&gt;

&lt;p&gt;就单个操作来说，给控件加圆角或者阴影的时候，如果操作不当，因为离屏渲染的问题，会导致比较严重的性能问题。尤其在流式布局如：UITableView、UICollectionView 上，如果添加多个带有阴影或圆角的子视图，性能损耗非常明显。&lt;/p&gt;

&lt;p&gt;一种折中方案：直接让美工把图片切成圆角进行显示，这是效率最高的一种方案。&lt;br /&gt;
虽然图片的解析和展示会占用一部分内存，但是这是典型的用空间换取时间的情况，在优化时间有限的情况下，让美工做图是个不错的选择。&lt;/p&gt;

&lt;p&gt;UIView、UILabel、UIImageView、UITextView 出现离屏渲染的条件存在略微差异，我们分开一一介绍。&lt;/p&gt;

&lt;h3 id=&quot;优化&quot;&gt;优化&lt;/h3&gt;
&lt;p&gt;在离屏渲染无法避免的时候，那么退而求其次，让离屏渲染的代价尽量小。一些优化措施可以尽可能的避免性能损耗过大。&lt;/p&gt;

&lt;p&gt;先说两个实现方案，然后针对离屏渲染问题进行优化：&lt;/p&gt;

&lt;p&gt;方案1: 在 view 上显示圆角效果，再在底部插一个阴影的layer。
    ``` 
    UIView *bgView = [[UIView alloc] initWithFrame:CGRectMake(50, 100, 100, 100)];
    bgView.backgroundColor = [UIColor brownColor];&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;bgView.layer.cornerRadius = 20.0f;
bgView.layer.masksToBounds = YES;

[self.view addSubview:bgView];

CALayer *subLayer=[CALayer layer];
CGRect fixframe = bgView.frame;
subLayer.frame= fixframe;
subLayer.cornerRadius=20;
subLayer.backgroundColor=[[UIColor blackColor] colorWithAlphaComponent:0.8].CGColor;
subLayer.masksToBounds=NO;
subLayer.shadowColor = [UIColor blackColor].CGColor;//shadowColor阴影颜色
subLayer.shadowOffset = CGSizeMake(3,2);//shadowOffset阴影偏移,x向右偏移3，y向下偏移2，默认(0, -3),这个跟shadowRadius配合使用
subLayer.shadowOpacity = 0.8;//阴影透明度，默认0
subLayer.shadowRadius = 4;//阴影半径，默认3
[self.view.layer insertSublayer:subLayer below:bgView.layer];
```
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;方案2: 不设置 layer.masksToBounds 。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;UIView *v=[[UIView alloc]initWithFrame:CGRectMake(200, 100, 100, 100)];
    v.backgroundColor=[UIColor brownColor];
    //v.layer.masksToBounds=YES;不设置 
    v.layer.cornerRadius=20;
    v.layer.shadowColor=[UIColor blackColor].CGColor;
    v.layer.shadowOffset=CGSizeMake(5, 5);
    v.layer.shadowOpacity=0.5;
    v.layer.shadowRadius=5;
    [self.view addSubview:v];
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;实际上，让一个控件既实现shadowPath&lt;/p&gt;

&lt;p&gt;下面的情况或操作会引发离屏渲染：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;为图层设置遮罩（layer.mask）&lt;/li&gt;
  &lt;li&gt;为图层设置阴影（layer.shadow *）。&lt;/li&gt;
  &lt;li&gt;为图层设置layer.shouldRasterize=true&lt;/li&gt;
  &lt;li&gt;文本（任何种类，包括UILabel，CATextLayer，Core Text等）。&lt;/li&gt;
  &lt;li&gt;将图层的layer.masksToBounds / view.clipsToBounds属性设置为true&lt;/li&gt;
  &lt;li&gt;将图层layer.allowsGroupOpacity属性设置为YES和layer.opacity小于1.0&lt;/li&gt;
  &lt;li&gt;具有layer.cornerRadius，layer.edgeAntialiasingMask，layer.allowsEdgeAntialiasing的图层&lt;/li&gt;
  &lt;li&gt;使用CGContext在drawRect :方法中绘制大部分情况下会导致离屏渲染，甚至仅仅是一个空的实现。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;优化方案1：使用贝塞尔曲线UIBezierPath和Core Graphics框架画出一个圆角&lt;/p&gt;

&lt;p&gt;优化方案2：使用CAShapeLayer和UIBezierPath设置圆角&lt;/p&gt;

&lt;p&gt;使用代码手动生成圆角Image设置到要显示的View上，利用UIBezierPath（CoreGraphics框架）画出来圆角图片&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Miaocf</name>
        
        
      </author>

      

      
        <category term="iOS" />
      

      
        <summary type="html">iOS 圆角+阴影+离屏渲染问题</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">CocoaPods 私有库搭建</title>
      <link href="http://localhost:4000/cocoapods-private" rel="alternate" type="text/html" title="CocoaPods 私有库搭建" />
      <published>2019-08-16T16:01:00+08:00</published>
      <updated>2019-08-16T16:01:00+08:00</updated>
      <id>http://localhost:4000/cocoapods-private</id>
      <content type="html" xml:base="http://localhost:4000/cocoapods-private">&lt;p&gt;在 iOS 开发过程中，经常会使用cocoapods管理三方库，如果自己的库不想公开，只方便自己公司的人用，该怎么办呢？这里介绍一下如何搭建一个私有的Pods库。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;CocoaPods的原理&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;创建私有库&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;cocoapods的原理&quot;&gt;CocoaPods的原理&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;第三方库会被编译成.a静态库供我们真正的工程使用。&lt;/strong&gt;&lt;br /&gt;
CocoaPods会将所有的第三方库以target的方式组成一个名为Pods的工程，该工程在Pods目录下。整个第三方库工程会生成一个名称为&lt;code class=&quot;highlighter-rouge&quot;&gt;libPods-xxx.a&lt;/code&gt;的静态库提供给主工程使用。对于资源文件，CocoaPods 提供了一个名为Pods-resources.sh的bash脚本，该脚本在每次项目编译的时候都会执行，将第三方库的各种资源文件复制到目标目录中。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;工程和第三方库所在的工程会由一个新生成的workspace管理&lt;/strong&gt;&lt;br /&gt;
为了方便我们直观的管理工程和第三方库，CocoaPodsTest工程和Pods工程会被以workspace的形式组织和管理，也就是xxxx.xcworkspace文件。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;CocoaPods通过&lt;code class=&quot;highlighter-rouge&quot;&gt;Pods-Podtest.release.xcconfig&lt;/code&gt;的文件来在编译时设置所有的依赖和参数。&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;原来的工程设置已经被更改了，直接打开原来的工程文件去编译就会报错，使用新生成的workspace来进行项目管理。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;创建私有库&quot;&gt;创建私有库&lt;/h3&gt;

&lt;p&gt;创建私有库的大体步骤为:&lt;/p&gt;

&lt;h4 id=&quot;1-准备工作&quot;&gt;1. 准备工作&lt;/h4&gt;

&lt;p&gt;创建两个私有远程仓库 Spec 和 Lib&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Spec仓库用来存储spec&lt;/li&gt;
  &lt;li&gt;Lib用来存储项目工程文件&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;2-创建pod私有库的项目工程&quot;&gt;2. 创建pod私有库的项目工程&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;cd到合适目录下用命令行创建工程,执行 &lt;code class=&quot;highlighter-rouge&quot;&gt;pod lib create Lib&lt;/code&gt; ,按提示输入需要的内容.&lt;/li&gt;
  &lt;li&gt;修改podspec文件&lt;/li&gt;
  &lt;li&gt;修改完成后,cd 到Lib目录下执行&lt;code class=&quot;highlighter-rouge&quot;&gt;pod lib lint&lt;/code&gt; &lt;br /&gt;
podspec 文件保存了所有要对三方库的配置,包括要引用的依赖、模块划分、源文件、公共头文件等.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;3-将本地项目文件上传到远程私有库中&quot;&gt;3. 将本地项目文件上传到远程私有库中&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git remote add origin http://git.xxxx.cn/APP/ios/Lib.git
$ git add .
$ git commit -m &quot;Initial commit&quot;
$ git push -u origin master
//tag 值要和podspec中的version一致
$ git tag 0.1.0
//推送tag到服务器上
$ git push --tags
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这时查看远程仓库应该有自己的项目文件了&lt;/p&gt;

&lt;h4 id=&quot;4-校验spec&quot;&gt;4. 校验spec&lt;/h4&gt;

&lt;p&gt;执行 &lt;code class=&quot;highlighter-rouge&quot;&gt;pod spec lint&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&quot;5创建spec-repo&quot;&gt;5.创建spec repo&lt;/h4&gt;

&lt;p&gt;进入文件夹&lt;code class=&quot;highlighter-rouge&quot;&gt;cd ~/.cocoapods/repos&lt;/code&gt; 可以查看本地&lt;code class=&quot;highlighter-rouge&quot;&gt;spec repo&lt;/code&gt;
指定管理 lib repo 的 specs repo 的 url
&lt;code class=&quot;highlighter-rouge&quot;&gt;pod repo add Lib http://git.xxxx.cn/APP/ios/Spec.git&lt;/code&gt;
注意 此处地址是spec仓库地址
推送 podspec 到 specs repo
&lt;code class=&quot;highlighter-rouge&quot;&gt;pod repo push Lib Lib.podspec --sources=http://git.xxx.cn/APP/ios/Spec.git&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&quot;6-验证&quot;&gt;6. 验证&lt;/h4&gt;
&lt;p&gt;创建一个新的项目  编写podfile文件&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;source 'http://git.xxxx.cn/APP/ios/Spec.git'

platform :ios, '9.0'

target 'TestPods' do
  use_frameworks!
  pod 'Lib'

end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;cd项目中 执行pod install&lt;/p&gt;

&lt;h4 id=&quot;7--更新spec文件&quot;&gt;7.  更新spec文件&lt;/h4&gt;
&lt;p&gt;更新 podspec 文件后:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;将更新的podspec 文件更新到 git 库&lt;/li&gt;
  &lt;li&gt;更新本地 repo 相关私有库的 podspec 文件,命令如下:
&lt;code class=&quot;highlighter-rouge&quot;&gt;zsspecs&lt;/code&gt; 是私有库的名称.&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  pod repo update zsspecs
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;subspec&quot;&gt;subspec&lt;/h3&gt;
&lt;p&gt;代表了一个库的其中一个模块的说明。
subspec 支持嵌套&lt;/p&gt;

&lt;h3 id=&quot;注意事项&quot;&gt;注意事项&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;pods 在安装的时候,遇到体积较大的文件会报&lt;code class=&quot;highlighter-rouge&quot;&gt;early EOF&lt;/code&gt;的错, 需要设置&lt;code class=&quot;highlighter-rouge&quot;&gt;postBuffer&lt;/code&gt;来解决这个问题&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ git config --global http.postBuffer 1073741824  
 $ git config --list
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;pod install&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;pod update&lt;/code&gt; 区别&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;pod update AFNetworking&lt;/code&gt; 单独更新某一个库.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;不更新 podspec&lt;br /&gt;
CocoaPods 在执行pod install和pod update时，会默认先更新一次podspec索引。使用–no-repo-update参数可以禁止其做索引更新操作。如下所示:&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; pod install --no-repo-update
 pod update --no-repo-update
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;使用私有的 pods&lt;br /&gt;
通过直接指定某一个依赖的podspec，就可以使用内部的私有库。有利于使企业内部的公共项目支持 CocoaPods。示例：&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;pod 'MyCommon', :podspec =&amp;gt; 'https://suning.com/common/myCommon.podspec'&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考资料&lt;br /&gt;
&lt;a href=&quot;https://guides.cocoapods.org/using/using-cocoapods.html&quot;&gt;cocoaPods文档&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.jianshu.com/p/3086df14ed08&quot;&gt;cocoaPods 原理&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://blog.devtang.com/2014/05/25/use-cocoapod-to-manage-ios-lib-dependency/&quot;&gt;cocoaPods 管理&lt;/a&gt; &lt;br /&gt;
&lt;a href=&quot;https://guides.cocoapods.org/syntax/podspec.html#subspec&quot;&gt;subspec&lt;/a&gt;&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Miaocf</name>
        
        
      </author>

      

      
        <category term="something" />
      

      
        <summary type="html">在 iOS 开发过程中，经常会使用cocoapods管理三方库，如果自己的库不想公开，只方便自己公司的人用，该怎么办呢？这里介绍一下如何搭建一个私有的Pods库。</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Time Range 如何影响你的人生</title>
      <link href="http://localhost:4000/time-range" rel="alternate" type="text/html" title="Time Range 如何影响你的人生" />
      <published>2019-07-01T10:53:00+08:00</published>
      <updated>2019-07-01T10:53:00+08:00</updated>
      <id>http://localhost:4000/time-range</id>
      <content type="html" xml:base="http://localhost:4000/time-range">&lt;p&gt;时间尺度对人生的影响&lt;/p&gt;

&lt;p&gt;hour
day
week
month
year
half-decade
decade
two-decade
three-decade&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Miaocf</name>
        
        
      </author>

      

      
        <category term="something" />
      

      
        <summary type="html">时间尺度对人生的影响</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">iOS 网络封装</title>
      <link href="http://localhost:4000/network-encapsulation" rel="alternate" type="text/html" title="iOS 网络封装" />
      <published>2019-07-01T10:53:00+08:00</published>
      <updated>2019-07-01T10:53:00+08:00</updated>
      <id>http://localhost:4000/network-encapsulation</id>
      <content type="html" xml:base="http://localhost:4000/network-encapsulation">&lt;p&gt;网络封装&lt;/p&gt;

&lt;p&gt;request:&lt;/p&gt;

&lt;p&gt;useragent&lt;/p&gt;

&lt;p&gt;cookies&lt;/p&gt;

&lt;p&gt;response:
errorcode&lt;/p&gt;

&lt;p&gt;302 301条转&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Miaocf</name>
        
        
      </author>

      

      
        <category term="something" />
      

      
        <summary type="html">网络封装</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">如何看待软件工程师</title>
      <link href="http://localhost:4000/software-engineer" rel="alternate" type="text/html" title="如何看待软件工程师" />
      <published>2019-07-01T10:53:00+08:00</published>
      <updated>2019-07-01T10:53:00+08:00</updated>
      <id>http://localhost:4000/software-engineer</id>
      <content type="html" xml:base="http://localhost:4000/software-engineer">&lt;p&gt;在目前的互联网行业中, 从事代码 coding 职业的人,通常被称为程序员或者码农. 事实上他们还有另一个更 &lt;em&gt;高大上&lt;/em&gt; 一点的名字: &lt;code class=&quot;highlighter-rouge&quot;&gt;软件工程师&lt;/code&gt;. 今天就一起深入的了解一下,这个职业都需要哪些基本能力.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;长时间996屹立不倒
往往一个需求或者工程为了赶工期,需要长时间的加班加点,或者解决一个紧急问题需要连夜解决,在这种时候,没有一个健壮的身体是扛不住的.身体是革命的本钱, 一个好的身体更是做软件开发最重要的本钱. 程序员加班猝死的新闻屡见报端,可见软件开发是需要一个健康的体魄的.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;熟悉业务流程
世界上的程序员有两种: 一种是给程序员写程序的程序员, 另一种是给非程序员写程序的程序员. 第二种程序员大多是针对企业或用户需求编写代码的程序员. 这种程序员需要对业务流程有着清晰的理解&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;实现业务功能, 
交互设计 
操作流程, 
逻辑 ,&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Miaocf</name>
        
        
      </author>

      

      
        <category term="something" />
      

      
        <summary type="html">在目前的互联网行业中, 从事代码 coding 职业的人,通常被称为程序员或者码农. 事实上他们还有另一个更 高大上 一点的名字: 软件工程师. 今天就一起深入的了解一下,这个职业都需要哪些基本能力.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Blog 搭建与部署</title>
      <link href="http://localhost:4000/blog" rel="alternate" type="text/html" title="Blog 搭建与部署" />
      <published>2019-06-11T02:00:00+08:00</published>
      <updated>2019-06-11T02:00:00+08:00</updated>
      <id>http://localhost:4000/blog</id>
      <content type="html" xml:base="http://localhost:4000/blog">&lt;p&gt;  将纯文本转换为静态博客网站，并将博客部署到 GitHubPage，绑定自有域名方便大家访问。&lt;/p&gt;

&lt;p&gt;  在搭建自己的博客网站时，我希望只专注于组织内容，页面生成、部署等其他不关键的工作尽量简单。现在已经有了比较好的方案可以满足以上需求。在这里介绍如何花费较少的精力去搭建一个静态页面的个人博客。在这里只说一下大概过程，具体细节 search the web，你会得到你想要的一切。&lt;/p&gt;

&lt;h3 id=&quot;1-博客静态网站工具&quot;&gt;1. 博客静态网站工具&lt;/h3&gt;

&lt;p&gt;   这里我们用 Markdown 格式去写一些博客，使用 &lt;a href=&quot;https://www.jekyll.com.cn/docs&quot;&gt;Jekyll&lt;/a&gt;、&lt;a href=&quot;https://hexo.io/zh-cn/&quot;&gt;Hexo&lt;/a&gt; 等转换工具，将纯文本文件转换为 HTML 页面。Jekyll、Hexo 两者的主要区别在于，Jekyll 需要 Ruby 环境，而 Hexo 只需要 NodeJS 运行环境。
   两者各有大量的主题可供选择，那么问题来了，究竟选择 Jekyll 还是 Hexo ？这里建议选择有你喜欢的主题的那个。因为我在搭博客的时候最先接触 Jekyll，所以在这里介绍一下 Jekyll 的配置方法。&lt;/p&gt;

&lt;p&gt;具体环境安装参考官方文档。&lt;/p&gt;

&lt;h3 id=&quot;2-模版配置&quot;&gt;2. 模版配置&lt;/h3&gt;

&lt;p&gt;  下载完模版后，需要修改 _config.yml 配置文件，里面包含了关于博客站点的大部分配置。
如果你具备一些前端技能，可以自定义模版里的一些样式。模版的目录结构可参考&lt;a href=&quot;https://www.jekyll.com.cn/docs/structure/&quot;&gt;官方文档&lt;/a&gt;，文档中详细地介绍了每个文件的具体功能。&lt;/p&gt;

&lt;h3 id=&quot;3-生成静态页面&quot;&gt;3. 生成静态页面&lt;/h3&gt;

&lt;p&gt;  在编辑博客时，保存操作会触发编译动作，将你的博客文本渲染成 Html 页面，在浏览器刷新即可看到最新的博客内容。在 Jekyll 转换完所有的文件之后，将默认在 &lt;code class=&quot;highlighter-rouge&quot;&gt;_site&lt;/code&gt; 下放置生成的站点文件。你也可以在 _config.yml 中添加配置 &lt;code class=&quot;highlighter-rouge&quot;&gt;destination: ../Blog_source/&lt;/code&gt; 设置相对路径，这样生成的站点文件就会存放在你设置的路径下，方便用 git 工具管理。&lt;/p&gt;

&lt;h3 id=&quot;4-github-设置&quot;&gt;4. GitHub 设置&lt;/h3&gt;

&lt;p&gt;  在这里，你需要创建一个 &lt;a href=&quot;https://pages.github.com&quot;&gt;github page&lt;/a&gt; repository，具体操作见文档。这个就是就是用来存放你站点文件的 repo。创建完毕之后，需要在 config.yml 文件中添加 github 相关的配置，配置项如下。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#gitment
owner: XXX
repo: XXX
branch: master
client_id: xxxxxxx
client_secret: xxxxxx
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;5-绑定域名&quot;&gt;5. 绑定域名&lt;/h3&gt;

&lt;p&gt;  首先你需要掏点银子买个自己的域名（摊手）,这里都是固定的操作没啥好说的，具体细节可以参考&lt;a href=&quot;https://cloud.tencent.com/developer/article/1421879&quot;&gt;这位施主&lt;/a&gt;文章。&lt;/p&gt;

&lt;p&gt;  当然你也可以不绑定域名，省下一笔银子来顿烧烤，但是作为一个独立 bloger ，自己的域名还是要有的，不然没有 bigger。&lt;/p&gt;

&lt;h3 id=&quot;6-添加评论和统计功能&quot;&gt;6. 添加评论和统计功能&lt;/h3&gt;

&lt;p&gt;  这个就需要你了解一点点前端的技能了，我们现说评论：评论有很多平台在做，比如“多说”，“畅言”，“友言”，“新浪云跟贴”，但大多都不太靠谱，关的关、封的封。这里 使用&lt;a href=&quot;https://imsun.net/posts/gitment-introduction/&quot;&gt;Gitment&lt;/a&gt;来实现博客的评论功能，具体细节可参考大神的文章。&lt;/p&gt;

&lt;p&gt;  关于统计，这个看你自己需不需要加。我这里加的是&lt;a href=&quot;https://tongji.baidu.com/web/welcome/login&quot;&gt;百度统计&lt;/a&gt;,官方有较详细的接入文档。可以查看博客的浏览人数和页面UV、PV。&lt;/p&gt;

&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;使用 GitHub page 存放博客，充当免费服务器的角色，Jekyll 将文本解析成 html 页面，这样博客一经建成，就无须维护，只需要专心写内容就可以了。&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Miaocf</name>
        
        
      </author>

      

      
        <category term="something" />
      

      
        <summary type="html">  将纯文本转换为静态博客网站，并将博客部署到 GitHubPage，绑定自有域名方便大家访问。</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">iOS 支付宝&amp;amp;微信-支付接口封装指南</title>
      <link href="http://localhost:4000/zfb-wx-payment" rel="alternate" type="text/html" title="iOS 支付宝&amp;微信-支付接口封装指南" />
      <published>2019-06-11T02:00:00+08:00</published>
      <updated>2019-06-11T02:00:00+08:00</updated>
      <id>http://localhost:4000/zfb-wx-payment</id>
      <content type="html" xml:base="http://localhost:4000/zfb-wx-payment">&lt;p&gt;微信支付宝 接口封装指南&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Miaocf</name>
        
        
      </author>

      

      
        <category term="iOS" />
      

      
        <summary type="html">微信支付宝 接口封装指南</summary>
      

      
      
    </entry>
  
</feed>
