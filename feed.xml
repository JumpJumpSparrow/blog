<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>CF Blog</title>
    <description>iOS 开发，会 1.5 点web前端，Java web入门开发者</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Fri, 06 Mar 2020 16:12:46 +0800</pubDate>
    <lastBuildDate>Fri, 06 Mar 2020 16:12:46 +0800</lastBuildDate>
    <generator>Jekyll v4.0.0</generator>
    
      <item>
        <title>批量并发-事件管理队列</title>
        <description>&lt;p&gt;首先描述一下背景：目前在做电商 APP 的页面改版，主要工作集中在商品详情页上。商品详情页的数据比较繁多，涉及到近 20 个网络接口。 这些接口中有的还存在依赖关系，而且重要程度也不尽相同。为了兼顾这些接口的并发性能和依赖关系，模仿 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_group&lt;/code&gt; 的接口设计，写了一个批量事件管理队列的工具 &lt;code class=&quot;highlighter-rouge&quot;&gt;EventScheduleManager&lt;/code&gt; 。&lt;/p&gt;

&lt;h3 id=&quot;模型抽象&quot;&gt;模型抽象&lt;/h3&gt;

&lt;p&gt;商品详情页需要的数据有：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;商品属性信息，包含商品ID、商品名、图册等等&lt;/li&gt;
  &lt;li&gt;商品销售信息，包含价格、销售状态、优惠信息&lt;/li&gt;
  &lt;li&gt;SKU/SPU 信息&lt;/li&gt;
  &lt;li&gt;商品运费信息&lt;/li&gt;
  &lt;li&gt;商品物流信息，最早可达时间信息&lt;/li&gt;
  &lt;li&gt;评价列表信息&lt;/li&gt;
  &lt;li&gt;推荐商品列表&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这里暂时列出这些&lt;/p&gt;

&lt;p&gt;根据以上列表不难看出，商品属性、销售信息和SKU/SPU信息最为重要，运费、物流信息次之，评价、推荐信息优先级最低。&lt;/p&gt;

&lt;p&gt;在这里，把所有事件分成多个批次，每个批次包含多个相互独立的事件，依次执行每个批次，
当优先级高的批次执行完之后，再执行优先级低的批次，如此形成一个队列。
因为执行队列保持顺序执行，依赖关系也被很好的隔离开来。
&lt;img src=&quot;/assets/article_assets/envent-schedule.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;代码实现&quot;&gt;代码实现&lt;/h3&gt;

&lt;p&gt;由于多个事件分为多个批次执行，而且批次之间需要保持顺序，所以这里使用单向链表构建事件队列。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/article_assets/eventScheduleUML.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;首先创建一个 队列模型类 &lt;code class=&quot;highlighter-rouge&quot;&gt;EventScheduleManager&lt;/code&gt;，然后在 &lt;code class=&quot;highlighter-rouge&quot;&gt;EventScheduleManager&lt;/code&gt; 的子类内部创建队列。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;EventUnit&lt;/code&gt;  事件类，包含唯一标志符、执行方法、执行状态。&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;EventMark&lt;/code&gt;  队列节点类，包含事件集合、批次名称&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;EventScheduleManager&lt;/code&gt;  队列管理类&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;EventScheduleDelegate&lt;/code&gt; 队列回调事件&lt;/p&gt;

&lt;p&gt;创建子类继承&lt;code class=&quot;highlighter-rouge&quot;&gt;EventScheduleManager&lt;/code&gt;，在子类内部创建队列：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Objective-C&quot;&gt;- (void)createSchedule {
    // 清空
    [self clearAllEvents];
    
    //第一阶段
    EventUnit *unit_1 = [EventUnit getEventWith:ProductDetailGetBasicInfo eventMethod:@&quot;ProductBasicInfo&quot;];

    EventMark *mark_1 = [EventMark getEventMarkWithEvents:@[unit_1]];
    mark_1.name = @&quot;第一阶段&quot;;
    
    [self push:mark_1];
    
    
    //第二阶段
    EventUnit *unit_2 = [EventUnit getEventWith:ProductDetailGetSaleInfo eventMethod:@&quot;ProductSaleInfo&quot;];
    EventUnit *unit_4 = [EventUnit getEventWith:ProductDetailItemUniqueInfo eventMethod:@&quot;ItemUniqueInfo&quot;];

    EventMark *mark_2 = [EventMark getEventMarkWithEvents:@[unit_2,unit_4]];
    mark_2.name = @&quot;第二阶段&quot;;
    
    [self push:mark_2];
    
    // 第一个 milestone 完成
    EventUnit *first = [EventUnit getEventWith:ProductDetailFirstStage eventMethod:@&quot;fistStageFinished&quot;];
    
    EventMark *firstMileStone = [EventMark getEventMarkWithEvents:@[first]];
    firstMileStone.name = @&quot;firstMileStone&quot;;
    
    [self push:firstMileStone];
    
    //第三阶段
    EventUnit *unit_8 = [EventUnit getEventWith:ProductDetailLogistics eventMethod:@&quot;LogisticsInfo&quot;];
    EventUnit *unit_9 = [EventUnit getEventWith:ProductDetailFreightInfo eventMethod:@&quot;FreightInfo&quot;];

    EventMark *mark_3 = [EventMark getEventMarkWithEvents:@[unit_8,unit_9]];
    mark_3.name = @&quot;第三阶段&quot;;
    
    [self push:mark_3];
    
    // 第二个 milestone 完成
    EventUnit *second = [EventUnit getEventWith:ProductDetailSecondStage eventMethod:@&quot;secondStageFinished&quot;];
    
    EventMark *secondMileStone = [EventMark getEventMarkWithEvents:@[second]];
    secondMileStone.name = @&quot;secondMileStone&quot;;
    
    [self push:secondMileStone];
    
    //第四阶段
    EventUnit *unit_10 = [EventUnit getEventWith:ProductDetailRecommend eventMethod:@&quot;RecommendInfo&quot;];
    EventUnit *unit_13 = [EventUnit getEventWith:ProductDetailComments eventMethod:@&quot;CommentsInfo&quot;];

    EventMark *mark_4 = [EventMark getEventMarkWithEvents:@[unit_10,unit_13]];
    mark_4.name = @&quot;第四阶段&quot;;
    
    [self push:mark_4];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;父类执行方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Objective-C&quot;&gt;// 开始执行
- (void)start {
    
    EventMark *events = [self pop];
    
    if (events) {
        
        [self excuteEvents:events];
        
    } else {
        // 所有事件执行完毕
        _currentEvents = nil;
        if ([self.delegate respondsToSelector:@selector(allEventsFinished)]) {
            [self.delegate allEventsFinished];
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-Objective-C&quot;&gt;// 执行事件
- (void)excuteEvents:(EventMark *)events{
    [self.lock lock];
    self.currentEvents = events;
    if ([self.delegate respondsToSelector:@selector(arriveOnEventSchedule:)]) {
        [self.delegate arriveOnEventSchedule:events];
    }
    [self.lock unlock];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在管理事件队列处，生成队列实例，创建队列，开启队列执行。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;    self.scheduleManager = [[ProductDetailSchedule alloc] init];  
    self.scheduleManager.delegate = self;  
    // 创建队列
    [self.scheduleManager createSchedule];  
    [self.scheduleManager start];
    
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;事件方法执行, 这里根据字符串转方法，在子线程异步执行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Objective-C&quot;&gt;- (void)arriveOnEventSchedule:(EventMark *)events{
    
    [events.events enumerateObjectsUsingBlock:^(EventUnit * _Nonnull obj, BOOL * _Nonnull stop) {
        
        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
                        
            SEL selector = NSSelectorFromString(obj.eventMethod);
            if ([self respondsToSelector:selector]) {
                
                IMP imp = [self methodForSelector:selector];
                void (*func)(id, SEL) = (void *)imp;
                func(self, selector);
            }
        });
    }];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/JumpJumpSparrow/EventScheduleManager.git&quot;&gt;Demo EventScheduleManager&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 18 Dec 2019 07:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/12/18/concurrent-events-queue/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/12/18/concurrent-events-queue/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>解决 H5 页面在手机上布局异常的问题</title>
        <description>&lt;p&gt;目前在做一款电商 APP，在商品详情页中，使用 webview 呈现 H5 内容来展现商品的图文详情。测试反馈说 H5 内容呈现样式发生异常，经研究是手机尺寸与PC尺寸存在差异，CSS 无法完全适配导致的。&lt;/p&gt;

&lt;p&gt;如图，图片显示不完整 ⤋
&lt;br /&gt;&lt;img src=&quot;/assets/images/iOS-webview-auto-scale/image_3.png&quot; width=&quot;200&quot; /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;把 URL string 放到PC上展示如下：⤋&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;img src=&quot;/assets/images/iOS-webview-auto-scale/image_5.png&quot; width=&quot;200&quot; /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;不难看出，这个详情页是把图片分割成多个部分，然后通过 CSS 布局拼接到一起的。&lt;/p&gt;

&lt;p&gt;拉伸 PC 浏览器窗口，可以看到我们想要的布局效果：⤋
&lt;br /&gt;&lt;img src=&quot;/assets/images/iOS-webview-auto-scale/image_4.png&quot; width=&quot;200&quot; /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot;&gt;// html 中，图片宽度为 750 px，
// 为了铺满屏幕，计算 initial-scale 初始缩放比例
// html 中的尺寸为 750, 手机使用的不是物理像素，而是点；
    
CGFloat w = [[UIScreen mainScreen] bounds].size.width;
CGFloat ratio = w/750.0;
&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;meta&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;charset=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'UTF-8'&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;meta&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'viewport'&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;content=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'width=device-width, initial-scale=1.0,minimum-scale=1.0, maximum-scale=1.0, user-scalable=0'&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;meta&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'format-detection'&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;content=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'telephone=no'&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;因为商品详情页在 PC 上的宽度为750像素， 我们根据手机频幕的宽度，计算出 H5 页面的缩放比例。&lt;br /&gt;
根据 H5 页面 头部 meta 信息，设置 &lt;code class=&quot;highlighter-rouge&quot;&gt;initial-scale&lt;/code&gt;初始缩放比例，通过注入 JS 调整初始缩放比例&lt;/p&gt;

&lt;p&gt;加载页面之前，注入一段 JS 代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot;&gt;CGFloat w = [[UIScreen mainScreen] bounds].size.width;
CGFloat ratio = w/750.0;

NSString *jScript = @&quot;var meta = document.createElement('meta'); meta.setAttribute('name', 'viewport'); meta.setAttribute('content', 'width=device-width,initial-scale=ratio,minimum-scale=0.30, maximum-scale=3.0, user-scalable=0'); meta.setAttribute('content', 'width=device-width'); document.getElementsByTagName('head')[0].appendChild(meta);&quot;;

jScript = [jScript stringByReplacingOccurrencesOfString:@&quot;ratio&quot; withString:[NSString stringWithFormat:@&quot;%f&quot;,ratio]];

WKUserScript *wkUScript = [[WKUserScript alloc] initWithSource:jScript injectionTime:WKUserScriptInjectionTimeAtDocumentEnd forMainFrameOnly:YES];
WKUserContentController *wkUController = [[WKUserContentController alloc] init];
[wkUController addUserScript:wkUScript];

WKWebViewConfiguration *wkWebConfig = [[WKWebViewConfiguration alloc] init];
wkWebConfig.userContentController = wkUController;

wkWebV = [[WKWebView alloc] initWithFrame:self.view.frame configuration:wkWebConfig];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样，webview 跟据当前 屏幕大小，自适应缩放 H5页面的大小。&lt;/p&gt;

&lt;p&gt;设置比例过小的效果图 ⤋
&lt;br /&gt;&lt;img src=&quot;/assets/images/iOS-webview-auto-scale/image_2.png&quot; width=&quot;200&quot; /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;设置缩放比例正确的效果 ⤋&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/iOS-webview-auto-scale/image_1.png&quot; width=&quot;200&quot; /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/26295277/wkwebview-equivalent-for-uiwebviews-scalespagetofit&quot;&gt;参考链接&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 18 Dec 2019 07:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/12/18/iOS-webviews-scales-page-to-fit/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/12/18/iOS-webviews-scales-page-to-fit/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>Hash Map</title>
        <description>&lt;p&gt;jj&lt;/p&gt;
</description>
        <pubDate>Wed, 18 Dec 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/12/18/hash-map/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/12/18/hash-map/</guid>
        
        
      </item>
    
      <item>
        <title>One To Many Interface Instruction</title>
        <description>
</description>
        <pubDate>Tue, 12 Nov 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/11/12/one-to-many-interface-instruction/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/11/12/one-to-many-interface-instruction/</guid>
        
        
      </item>
    
      <item>
        <title>What Do You Think About Difference</title>
        <description>&lt;p&gt;如何看待 ‘不同’？&lt;/p&gt;

&lt;p&gt;什么是不同？&lt;/p&gt;

&lt;p&gt;不同带来的优势？&lt;/p&gt;

&lt;p&gt;什么是优势？&lt;/p&gt;

</description>
        <pubDate>Sun, 10 Nov 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/11/10/what-do-you-think-about-difference/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/11/10/what-do-you-think-about-difference/</guid>
        
        
      </item>
    
      <item>
        <title>关于自动驾驶伦理问题的思考</title>
        <description>&lt;p&gt;  在这里主要讨论自动驾驶技术的实际应用中，可能遇到的社会伦理问题以及相关思考。&lt;/p&gt;

&lt;p&gt;  目前市场上已经出现了可以自动驾驶的汽车，比如特斯拉、百度的阿波龙。 其中自动驾驶应用较为激进的当属特斯拉无疑。近几年 (2016-2018) 特斯拉的几起事故，可能与自动驾驶技术尚未完全成熟有关。而百度已获得全国首批T4道路测试牌照，自动驾达到L4级别的&lt;a href=&quot;http://apollo.auto/minibus/index_cn.html&quot;&gt;阿波龙&lt;/a&gt;已经于2018年7月4日正式量产下线，已经在多地开始展开试用。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/autopilot/apollo.jpg&quot; style=&quot;zoom:70%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;（图为阿波龙自动驾驶汽车）&lt;/p&gt;

&lt;p&gt;  随着人工智能 AI (&lt;code class=&quot;highlighter-rouge&quot;&gt;Artificial Intelligence&lt;/code&gt;) 的事件处理能力和数据分析精度变得更强更高，自动驾驶技术也开始进入了实用阶段。当然，实现自动驾驶除了 AI 必不可少以外，还需要&lt;code class=&quot;highlighter-rouge&quot;&gt;计算机视觉&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;高精度地图&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;5G高速通信技术&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;激光雷达&lt;/code&gt;等环境感知技术。可以预见到不久的将来，自动驾驶功能将会成为汽车的标配功能，&lt;code class=&quot;highlighter-rouge&quot;&gt;AI&lt;/code&gt; 也继 &lt;code class=&quot;highlighter-rouge&quot;&gt;水&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;电&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;网络&lt;/code&gt;之后，势必成为生活中必不可少的基础元素，潜入到生活的方方面面。&lt;/p&gt;

&lt;p&gt;  然而 AI 作为自动驾驶的主要决策单元，代替驾驶员做出决策，控制车辆在道路上行走，这将带来一系列的社会伦理问题和法律问题。在这里列出一些自动驾驶在不久的将来可能会遇到的问题，与大家一起讨论、思考。&lt;/p&gt;

&lt;h4 id=&quot;问题1&quot;&gt;问题1&lt;/h4&gt;

&lt;p&gt;自动驾驶汽车行驶过程中，遇突发事故，选择避让可能危及行人生命安全，不避让可能会导致乘客伤亡，AI 该如何决策？&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/autopilot/user-innocent-accident.png&quot; style=&quot;zoom:70%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里有三个问题需要回答：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;用户&lt;/em&gt;&lt;/strong&gt;和&lt;strong&gt;&lt;em&gt;行人&lt;/em&gt;&lt;/strong&gt;都是无辜者，AI 有了干预的机会后，突来的意外应该降临到谁身上？&lt;/li&gt;
  &lt;li&gt;自动驾驶汽车作为一款产品，AI 是优先保护用户的安全？还是优先保护行人的安全？&lt;/li&gt;
  &lt;li&gt;遇到以上场景，自动驾驶是否需要&lt;strong&gt;&lt;em&gt;乘客&lt;/em&gt;&lt;/strong&gt;做出决策？或者说乘客的决定和AI的决定哪个有效？（自动驾驶里弱化了 司机 的角色，司机更多是 可以干预驾驶的乘客）&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;问题2&quot;&gt;问题2&lt;/h4&gt;

&lt;p&gt;一辆火车失控，即将撞向铁路上的五个人，这时 AI 可以控制扳手让火车转向，撞向另外一条轨道上的一个人。是将伤亡将到最小，还是让事故继续发生？&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/autopilot/which-one-to-choose.png&quot; style=&quot;zoom:70%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;人性、道德、法律，到底是谁做出了最终抉择？&lt;/p&gt;

&lt;p&gt;  这其实是美国哈佛大学政治哲学教授迈克尔·桑德尔，在公开课中设想的场景，用以描述行为选择的道德困境。在这里只是把人改为了 AI。在这里，不管 AI 如何处理，其最终决的选择实际来自于人，或者来自于人已经定制好的算法，AI 通过算法计算，忠实地执行了这个决定。&lt;/p&gt;

&lt;p&gt;  人可以为自己的决策和行为负责，那么AI的决策和行为谁来负责呢？&lt;/p&gt;

&lt;p&gt;  我认为这应该是社会群体层的共识问题，社会群体中的每个个体需要事先知晓 并接受 AI 的决策策略，在事故发生后， 所有人必须为算法的执行结果负责，因为这个是整个社会群体已经认可的选择。&lt;/p&gt;

&lt;p&gt;  当然 在现实中很难发生这种特殊情况，特别案例还需要根据实际情况具体分析，这里只是纯为讨论而假设的场景。&lt;/p&gt;

&lt;p&gt;自动驾驶不光光是 技术上的问题，法律和相关规范 是自动驾驶可以正常运行的必要条件。&lt;/p&gt;

&lt;p&gt;期待自动驾驶早点普及使用，在那之前，希望相关法律和规范已经落地执行。&lt;/p&gt;

&lt;p&gt;还有，没事不要到马路上溜达。&lt;/p&gt;

&lt;h3 id=&quot;end&quot;&gt;end&lt;/h3&gt;

&lt;p&gt;  写文章很有难度啊，写不下去了先在这里吐个槽，提升写作能力太有必要了。清楚明白地表达观点，并且让读者轻易的捕捉到你要表达的意思 ，让文章读起来感觉顺畅，同时保持整体有结构和层次，这些都不是那么容易的兼顾的到。想要提升写作能力，一番磨练必不可少啊。&lt;/p&gt;

&lt;p&gt;有问题或想法可以联系我讨论，邮箱：&lt;code class=&quot;highlighter-rouge&quot;&gt;meowchunfat@hotmail.com&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;声明：本篇为个人原创，允许转载，转载请注明出处。&lt;/p&gt;
</description>
        <pubDate>Fri, 08 Nov 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/11/08/auto-pilot-ethics/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/11/08/auto-pilot-ethics/</guid>
        
        <category>something</category>
        
        
      </item>
    
      <item>
        <title>技术是如何产生价值的？</title>
        <description>&lt;p&gt;什么是技术？ 技术就是将理论付诸实践的方法论。&lt;/p&gt;

&lt;p&gt;什么是理论？
什么是设计？&lt;/p&gt;

&lt;p&gt;首先，从哲学角度讲，物质结构决定物质功能。&lt;/p&gt;

&lt;p&gt;技术如何创造价值&lt;/p&gt;

&lt;p&gt;物质价值
实物、数据&lt;/p&gt;

&lt;p&gt;虚拟价值
服务
感受&lt;/p&gt;
</description>
        <pubDate>Fri, 25 Oct 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/10/25/how-dose-technology-create-values/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/10/25/how-dose-technology-create-values/</guid>
        
        <category>thoughts</category>
        
        
      </item>
    
      <item>
        <title>iOS 关于 UIView 重绘的几个接口</title>
        <description>&lt;p&gt;在更新数据时，往往伴随着更新 UI 布局。如何触发系统去刷新 UI 绘制呢？以下方法你需要了解一下。&lt;/p&gt;

&lt;h3 id=&quot;setneedslayout&quot;&gt;setNeedsLayout&lt;/h3&gt;
&lt;p&gt;Invalidates the current layout of the receiver and triggers a layout update during the next update cycle.&lt;br /&gt;
Call this method on your application’s main thread when you want to adjust the layout of a view’s subviews. This method makes a note of the request and returns immediately. Because this method does not force an immediate update, but instead waits for the next update cycle, you can use it to invalidate the layout of multiple views before any of those views are updated. This behavior allows you to consolidate all of your layout updates to one update cycle, which is usually better for performance.&lt;/p&gt;

&lt;h3 id=&quot;layoutifneeded&quot;&gt;layoutIfNeeded&lt;/h3&gt;
&lt;p&gt;Recalculate the receiver’s layout, if required.&lt;/p&gt;

&lt;p&gt;When this message is received, the layer’s super layers are traversed until a ancestor layer is found that does not require layout. Then layout is performed on the entire layer-tree beneath that ancestor.&lt;/p&gt;

&lt;h3 id=&quot;layoutsubviews&quot;&gt;layoutSubviews&lt;/h3&gt;

&lt;p&gt;The default implementation of this method does nothing on iOS 5.1 and earlier. Otherwise, the default implementation uses any constraints you have set to determine the size and position of any subviews.&lt;/p&gt;

&lt;p&gt;Subclasses can override this method as needed to perform more precise layout of their subviews. You should override this method only if the autoresizing and constraint-based behaviors of the subviews do not offer the behavior you want. You can use your implementation to set the frame rectangles of your subviews directly.&lt;/p&gt;

&lt;p&gt;You should not call this method directly. If you want to force a layout update, call the &lt;code class=&quot;highlighter-rouge&quot;&gt;setNeedsLayout&lt;/code&gt; method instead to do so prior to the next drawing update. If you want to update the layout of your views immediately, call the &lt;code class=&quot;highlighter-rouge&quot;&gt;layoutIfNeeded&lt;/code&gt; method.&lt;/p&gt;

&lt;h3 id=&quot;setneedsdisplay&quot;&gt;setNeedsDisplay&lt;/h3&gt;

&lt;p&gt;Recalculate the receiver’s layout, if required.&lt;br /&gt;
When this message is received, the layer’s super layers are traversed until a ancestor layer is found that does not require layout. Then layout is performed on the entire layer-tree beneath that ancestor.&lt;/p&gt;
</description>
        <pubDate>Fri, 18 Oct 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/10/18/UIView-drawing-cycle/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/10/18/UIView-drawing-cycle/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>iOS Emoji 过滤</title>
        <description>&lt;p&gt;  因为 emoji 字符在转码或存入数据库时，会遇到一些异常，因此在开发过程中，有过滤 emoji 或者禁止输入 emoji 的需求。&lt;/p&gt;

&lt;h3 id=&quot;什么是-emoji-&quot;&gt;什么是 emoji ？&lt;/h3&gt;
&lt;p&gt;  emoji 最早是由日本人&lt;em&gt;栗田穰崇&lt;/em&gt; (Shigetaka Kurita)创作的。emoji 是一些图形符号，例如：😊👏🚗🌞。和普通文字符号不同，emoji 通过一些图案来表达一些辨识度较高的场景或者含义，使阅读体验更好。在此可以查找各种 emoji &lt;a href=&quot;https://emojipedia.org&quot;&gt;emojipedia&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;(未完待续)d&lt;/p&gt;
</description>
        <pubDate>Sun, 13 Oct 2019 01:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/10/13/emoji-filter/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/10/13/emoji-filter/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>iOS universal-link 通用链接配置</title>
        <description>&lt;p&gt;iOS 通过 universal-link 唤起 APP 的难点在于：这是个纯配置的工作，需要配置服务端和APP端，还要在开发者账号中进行配置，并无特殊技巧。&lt;/p&gt;

&lt;p&gt;1.概念&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;https://weixin.qq.com/apple-app-site-association&lt;/code&gt;
https://developer.apple.com/library/archive/documentation/General/Conceptual/AppSearch/UniversalLinks.html#//apple_ref/doc/uid/TP40016308-CH12-SW1&lt;/p&gt;

&lt;p&gt;2.流程&lt;br /&gt;
3.配置项&lt;br /&gt;
4.流程图&lt;br /&gt;
（待完成）&lt;/p&gt;
</description>
        <pubDate>Fri, 11 Oct 2019 02:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/10/11/universal-link/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/10/11/universal-link/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
  </channel>
</rss>
