<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>CF Blog</title>
    <description>iOS 开发，会 1.5 点web前端，Java web入门开发者</description>
    <link>http://junziboxue.com/</link>
    <atom:link href="http://junziboxue.com/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Thu, 20 Aug 2020 09:19:40 +0800</pubDate>
    <lastBuildDate>Thu, 20 Aug 2020 09:19:40 +0800</lastBuildDate>
    <generator>Jekyll v4.1.1</generator>
    
      <item>
        <title>Flutter 渐变AppBar</title>
        <description>&lt;p&gt;最近要用 Flutter 重构一个 Native 页面，效果如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/fadeAppBar.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;随着页面滑动，圆形按钮逐渐消失，返回按钮逐渐呈现，同时AppBar的透明度在整个过程中，是随着滑动距离线性变化的，而按钮的变化分为两段：圆形按钮逐渐消失，返回按钮逐渐呈现，整个过程可逆。&lt;/p&gt;

&lt;p&gt;接下来介绍实现过程。&lt;/p&gt;

&lt;h4 id=&quot;1整体结构设计&quot;&gt;1.整体结构设计&lt;/h4&gt;

&lt;p&gt;通过观察可知，listView 可以在 AppBar 底部滑动，常规的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Scaffold&lt;/code&gt; widget 无法满足这个需求，而 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Stack&lt;/code&gt; widget 可以实现组件的叠加，在这里通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Stack&lt;/code&gt; 作为页面的 root widget。通过监听scrollView 的滑动距离，实时计算 appBar 和 按钮 的透明度。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Dart&quot;&gt;///首先声明 全局变量
  AppBarWidget appBar;
  ScrollController scrollController; //scrollView的控制器
  PositionedBtnWidget roundLeftBtn; //圆形返回按钮
  PositionedBtnWidget rectLeftBtn;  //方形返回按钮
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在初始化方法里，给全局变量赋值：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Dart&quot;&gt; @override
  void initState() {
    super.initState();
    appBar = AppBarWidget();
    scrollController = ScrollController();
    roundLeftBtn = PositionedBtnWidget();
    rectLeftBtn = PositionedBtnWidget();
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;整体UI结构使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Scaffold &lt;/code&gt;作为主框架，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;body&lt;/code&gt;部分则是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Stack &lt;/code&gt;，底部 TabBar使用 Scaffold 自带属性自定义搭建。为了适配 iPhoneX 底部，需要计算 安全区域高度。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt; MediaQuery.of(context).padding.bottom;&lt;/code&gt; ，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CustomScrollView&lt;/code&gt; 的controller 继承自 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ChangeNotifier&lt;/code&gt;，可监听其位置变化。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;///示意代码
Scaffold(
        body: Stack(
          children: &amp;lt;Widget&amp;gt;[
            ///监听滚动
            NotificationListener(
              onNotification: (notification) {
                if (notification is ScrollUpdateNotification &amp;amp;&amp;amp;
                    notification.depth == 0) {
                  ///滑动通知
           scrollViewDidScrolled(notification.metrics.pixels);
                }
                ///通知不再上传
                return true;
              },
              child: CustomScrollView(),
            appBar,
            rectLeftBtn,
            roundLeftBtn,
          ],
        ),
        bottomNavigationBar: Container(
            color: Colors.orange,
            height: bottomBarHeight,
            child: Center(
              child: Text('bottom bar'),
            )));
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;2其他部件的搭建&quot;&gt;2.其他部件的搭建&lt;/h4&gt;

&lt;p&gt;因为要实现透明度效果，这里使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Opacity&lt;/code&gt; widegt 来实现。控制 opacity 透明度的值，可实现透明度的变化。注意：在这里发现，Stack内的两个组件，如果发生重叠，位于顶部的widget最先响应点击事件。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;///示例
Opacity(
      opacity: opacity,
      child: Container(
        height: appBarHeight,
        child: AppBar(
          title: Text('app bar'),
          backgroundColor: Colors.deepOrange,
        ),
      ),
    );
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在 Stack 内部，变动部件位置需要用到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Positioned&lt;/code&gt; widegt, 点击事件通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IconButton&lt;/code&gt; 来实现&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;Positioned(
      top: btnTop,
      right: right,
      left: left,
      child: Opacity(
        opacity: btnOpacity,
        child: IconButton(
          icon: Image.asset(image),
          onPressed: () {
            if (widget != null &amp;amp;&amp;amp; widget.actionFunction != null) {
              widget.actionFunction();
            }
          },
        ),
      ),
    );
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;3透明度计算&quot;&gt;3.透明度计算&lt;/h4&gt;

&lt;p&gt;通过监听 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;scrollview&lt;/code&gt;的滑动距离，计算各个部件的透明度。
在这里 把完全透明到不透明 需要滑动的距离定为 80（单位逻辑像素 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;logical pixels&lt;/code&gt;）
而按钮 的变化分为两段，每段滑动距离为整体的一半，也就是40逻辑像素。
具体计算方式如下：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt; double maxOffset = 80.0;

  scrollViewDidScrolled(double offSet) {
    //print('scroll offset ' + offSet.toString());

    ///appbar 透明度
    double appBarOpacity = offSet / maxOffset;
    double halfPace = maxOffset / 2.0;

    ///圆形按钮透明度
    double roundOpacity = (halfPace - offSet) / halfPace;

    ///方形按钮透明度
    double rectOpacity = (offSet - halfPace) / halfPace;

    if (appBarOpacity &amp;lt; 0) {
      appBarOpacity = 0.0;
    } else if (appBarOpacity &amp;gt; 1) {
      appBarOpacity = 1.0;
    }

    if (roundOpacity &amp;lt; 0) {
      roundOpacity = 0.0;
    } else if (roundOpacity &amp;gt; 1) {
      roundOpacity = 1;
    }

    if (rectOpacity &amp;lt; 0) {
      rectOpacity = 0.0;
    } else if (rectOpacity &amp;gt; 1) {
      rectOpacity = 1.0;
    }
    //print('roundOpacity $roundOpacity rectOpacity $rectOpacity');

    ///更新透明度
    if (appBar != null &amp;amp;&amp;amp; appBar.updateAppBarOpacity != null) {
      appBar.updateAppBarOpacity(appBarOpacity);
    }

    if (roundLeftBtn != null &amp;amp;&amp;amp; roundLeftBtn.updateOpacity != null) {
      roundLeftBtn.updateOpacity(roundOpacity);
    }
    if (rectLeftBtn != null &amp;amp;&amp;amp; rectLeftBtn.updateOpacity != null) {
      rectLeftBtn.updateOpacity(rectOpacity);
    }
  }

&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;代码地址&lt;br /&gt;
&lt;a href=&quot;https://github.com/JumpJumpSparrow/Flutter-FadeAppBar.git&quot;&gt;Demo&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Mon, 10 Aug 2020 18:30:00 +0800</pubDate>
        <link>http://junziboxue.com/flutter-fade-app-bar</link>
        <guid isPermaLink="true">http://junziboxue.com/flutter-fade-app-bar</guid>
        
        <category>Flutter</category>
        
        
      </item>
    
      <item>
        <title>Jekyll 环境的搭建</title>
        <description>&lt;p&gt;最近换了台电脑，需要重新安装Jekyll环境，在这里记录下Mac安装Jekyell的过程。&lt;/p&gt;

&lt;h3 id=&quot;一环境准备&quot;&gt;一.环境准备&lt;/h3&gt;

&lt;p&gt;在安装Jekyll之前，需要具备以下条件：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Xcode 命令行&lt;/li&gt;
  &lt;li&gt;Homebrew&lt;/li&gt;
  &lt;li&gt;Ruby&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;1-homebrew&quot;&gt;1. Homebrew&lt;/h4&gt;

&lt;p&gt;什么是 &lt;a href=&quot;https://brew.sh&quot;&gt;Homebrew&lt;/a&gt; ?. 用一句话说明：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Homebrew installs the stuff you need that Apple (or your Linux system) didn’t.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/how-to-install-jekyll/homebrew.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Homebrow安装：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;/bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)&quot;

&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;将以上内容粘贴到命令窗口，即可安装 Homebrew，中途可能需要输入用户密码。&lt;/p&gt;

&lt;h4 id=&quot;2-安装命令行工具&quot;&gt;2. 安装命令行工具&lt;/h4&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;xcode-select --install
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;如果你已经安装了Xcode，无需进行此步。&lt;/p&gt;

&lt;h4 id=&quot;3安装ruby&quot;&gt;3.安装Ruby&lt;/h4&gt;

&lt;p&gt;Jekyll 需要 2.5.0以上版本的 Ruby，macOS Catalina 10.15 自带 ruby 2.6.3，如果你是之前的 mac 系统，需要更新下Ruby。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;
brew install ruby

添加路径
echo 'export PATH=&quot;/usr/local/opt/ruby/bin:$PATH&quot;' &amp;gt;&amp;gt; ~/.bash_profile
echo 'export PATH=&quot;$HOME/.gem/ruby/X.X.0/bin:$PATH&quot;' &amp;gt;&amp;gt; ~/.bash_profile
‘X.X.0’为本地Ruby版本
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;4安装jekyll&quot;&gt;4.安装Jekyll&lt;/h4&gt;

&lt;p&gt;安装 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Bundler and Jekyll&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;gem install --user-install bundler jekyll
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;创建测试&quot;&gt;创建测试&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;jekyll new my-awesome-site
cd my-awesome-site
~/my-awesome-site $ bundle exec jekyll serve
# =&amp;gt; Now browse to http://localhost:4000
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;如果已经创建 Jekyll，可能需要运行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gem update jekyll&lt;/code&gt;来更新Jekyll。
然后使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bundle update&lt;/code&gt;来更新依赖的包&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://jekyllrb.com&quot;&gt;参考资料&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Mon, 10 Aug 2020 18:30:00 +0800</pubDate>
        <link>http://junziboxue.com/install-jekyll</link>
        <guid isPermaLink="true">http://junziboxue.com/install-jekyll</guid>
        
        <category>jekyll</category>
        
        
      </item>
    
      <item>
        <title>深入了解 UINavigationController 的子控制器栈</title>
        <description>&lt;h3 id=&quot;1遇到一个需求&quot;&gt;1.遇到一个需求&lt;/h3&gt;
&lt;p&gt;使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UINavigationController &lt;/code&gt;push进入多个页面后，不再显示部分页面，直接返回到指定的页面。&lt;/p&gt;

&lt;p&gt;根据描述，第一个想到的方案就是:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt; [self.navigationController popToViewController:toVC animated:YES];
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;通过遍历&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UINavigationController&lt;/code&gt;的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;viewControllers&lt;/code&gt;找到要跳转的页面，直接pop过去。&lt;/p&gt;

&lt;p&gt;遇到的问题就是，iOS 触发返回页面有两种交互方式：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;点击左上角的返回按钮&lt;/li&gt;
  &lt;li&gt;使用手势，在屏幕边缘从左往右滑动&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;要想使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pop&lt;/code&gt;的API，就需要拦截边缘滑动的交互事件，重写&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UINavigationController&lt;/code&gt;的手势，（有的朋友说可以屏蔽右滑手势…）&lt;br /&gt;
由于不想改动 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UINavigationController&lt;/code&gt;的手势事件，遂有了下一个方案。&lt;/p&gt;

&lt;h3 id=&quot;2uinavigationcontroller实现原理&quot;&gt;2.&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UINavigationController&lt;/code&gt;实现原理&lt;/h3&gt;
&lt;p&gt;在iOS开发过程中，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UINavigationController &lt;/code&gt;是常用的容器类Controller，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UINavigationController &lt;/code&gt;交互方式如下图，&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../assets/images/UINavigationController/navigation-interface.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;根据官方文档说明，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UINavigationController&lt;/code&gt;通过管理一个用数组实现的栈结构来管理&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;childControllers &lt;/code&gt;。 将&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UIViewController&lt;/code&gt;依次压入栈中，记录了页面的先后顺序，同时栈持有子视图，实现了内存的管理。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../assets/images/UINavigationController/objects-managed-by-navi.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;3解决方案&quot;&gt;3.解决方案&lt;/h3&gt;
&lt;p&gt;于是想到，通过修改&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UINavigationController&lt;/code&gt;&lt;strong&gt;&lt;em&gt;栈内元素&lt;/em&gt;&lt;/strong&gt;来控制页面的跳转。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;    NSMutableArray *vcStack = [NSMutableArray arrayWithArray:self.navigationController.viewControllers];
    if (vcStack.count &amp;gt; 2 &amp;amp;&amp;amp; vcStack.count &amp;gt; index) {
        //将 元素直接从 数组中 移除
        [vcStack removeObjectAtIndex:index];
        self.navigationController.viewControllers = vcStack;
    }
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这样，在进入新的页面时，将不再显示的页面从栈中移除掉，便可实现跨页面的跳转。&lt;/p&gt;

&lt;p&gt;需要注意的是：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;当把一个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UIViewController&lt;/code&gt;的实例push进栈后，该实例的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;parentViewController&lt;/code&gt;就是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UINavigationController&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UIViewController&lt;/code&gt;的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;- (void)removeFromParentViewController&lt;/code&gt;方法，会将该实例从栈中移除，但会发生异常，具体表现为点击返回，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;navigationBar&lt;/code&gt; 有动画，但不会有页面跳转&lt;/li&gt;
  &lt;li&gt;注意内存的引用，如果要移除的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UIViewController &lt;/code&gt;在其他地方存在引用，将不会释放内存，发生内存泄露。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;附：UI结构图&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../assets/images/UINavigationController/views-of-navi.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;参考资料：&lt;br /&gt;
&lt;a href=&quot;https://developer.apple.com/documentation/uikit/uinavigationcontroller?language=objc&quot;&gt;UINavigationController&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Mon, 22 Jun 2020 18:30:00 +0800</pubDate>
        <link>http://junziboxue.com/ios-navigationcontroller</link>
        <guid isPermaLink="true">http://junziboxue.com/ios-navigationcontroller</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>批量并发-事件管理队列</title>
        <description>&lt;p&gt;首先描述一下背景：目前在做电商 APP 的页面改版，主要工作集中在商品详情页上。商品详情页的数据比较繁多，涉及到近 20 个网络接口。 这些接口中有的还存在依赖关系，而且重要程度也不尽相同。为了兼顾这些接口的并发性能和依赖关系，模仿 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dispatch_group&lt;/code&gt; 的接口设计，写了一个批量事件管理队列的工具 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EventScheduleManager&lt;/code&gt; 。&lt;/p&gt;

&lt;h3 id=&quot;模型抽象&quot;&gt;模型抽象&lt;/h3&gt;

&lt;p&gt;商品详情页需要的数据有：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;商品属性信息，包含商品ID、商品名、图册等等&lt;/li&gt;
  &lt;li&gt;商品销售信息，包含价格、销售状态、优惠信息&lt;/li&gt;
  &lt;li&gt;SKU/SPU 信息&lt;/li&gt;
  &lt;li&gt;商品运费信息&lt;/li&gt;
  &lt;li&gt;商品物流信息，最早可达时间信息&lt;/li&gt;
  &lt;li&gt;评价列表信息&lt;/li&gt;
  &lt;li&gt;推荐商品列表&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这里暂时列出这些&lt;/p&gt;

&lt;p&gt;根据以上列表不难看出，商品属性、销售信息和SKU/SPU信息最为重要，运费、物流信息次之，评价、推荐信息优先级最低。&lt;/p&gt;

&lt;p&gt;在这里，把所有事件分成多个批次，每个批次包含多个相互独立的事件，依次执行每个批次，
当优先级高的批次执行完之后，再执行优先级低的批次，如此形成一个队列。
因为执行队列保持顺序执行，依赖关系也被很好的隔离开来。
&lt;img src=&quot;/assets/article_assets/envent-schedule.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;代码实现&quot;&gt;代码实现&lt;/h3&gt;

&lt;p&gt;由于多个事件分为多个批次执行，而且批次之间需要保持顺序，所以这里使用单向链表构建事件队列。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/article_assets/eventScheduleUML.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;首先创建一个 队列模型类 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EventScheduleManager&lt;/code&gt;，然后在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EventScheduleManager&lt;/code&gt; 的子类内部创建队列。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EventUnit&lt;/code&gt;  事件类，包含唯一标志符、执行方法、执行状态。&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EventMark&lt;/code&gt;  队列节点类，包含事件集合、批次名称&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EventScheduleManager&lt;/code&gt;  队列管理类&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EventScheduleDelegate&lt;/code&gt; 队列回调事件&lt;/p&gt;

&lt;p&gt;创建子类继承&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EventScheduleManager&lt;/code&gt;，在子类内部创建队列：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Objective-C&quot;&gt;- (void)createSchedule {
    // 清空
    [self clearAllEvents];
    
    //第一阶段
    EventUnit *unit_1 = [EventUnit getEventWith:ProductDetailGetBasicInfo eventMethod:@&quot;ProductBasicInfo&quot;];

    EventMark *mark_1 = [EventMark getEventMarkWithEvents:@[unit_1]];
    mark_1.name = @&quot;第一阶段&quot;;
    
    [self push:mark_1];
    
    
    //第二阶段
    EventUnit *unit_2 = [EventUnit getEventWith:ProductDetailGetSaleInfo eventMethod:@&quot;ProductSaleInfo&quot;];
    EventUnit *unit_4 = [EventUnit getEventWith:ProductDetailItemUniqueInfo eventMethod:@&quot;ItemUniqueInfo&quot;];

    EventMark *mark_2 = [EventMark getEventMarkWithEvents:@[unit_2,unit_4]];
    mark_2.name = @&quot;第二阶段&quot;;
    
    [self push:mark_2];
    
    // 第一个 milestone 完成
    EventUnit *first = [EventUnit getEventWith:ProductDetailFirstStage eventMethod:@&quot;fistStageFinished&quot;];
    
    EventMark *firstMileStone = [EventMark getEventMarkWithEvents:@[first]];
    firstMileStone.name = @&quot;firstMileStone&quot;;
    
    [self push:firstMileStone];
    
    //第三阶段
    EventUnit *unit_8 = [EventUnit getEventWith:ProductDetailLogistics eventMethod:@&quot;LogisticsInfo&quot;];
    EventUnit *unit_9 = [EventUnit getEventWith:ProductDetailFreightInfo eventMethod:@&quot;FreightInfo&quot;];

    EventMark *mark_3 = [EventMark getEventMarkWithEvents:@[unit_8,unit_9]];
    mark_3.name = @&quot;第三阶段&quot;;
    
    [self push:mark_3];
    
    // 第二个 milestone 完成
    EventUnit *second = [EventUnit getEventWith:ProductDetailSecondStage eventMethod:@&quot;secondStageFinished&quot;];
    
    EventMark *secondMileStone = [EventMark getEventMarkWithEvents:@[second]];
    secondMileStone.name = @&quot;secondMileStone&quot;;
    
    [self push:secondMileStone];
    
    //第四阶段
    EventUnit *unit_10 = [EventUnit getEventWith:ProductDetailRecommend eventMethod:@&quot;RecommendInfo&quot;];
    EventUnit *unit_13 = [EventUnit getEventWith:ProductDetailComments eventMethod:@&quot;CommentsInfo&quot;];

    EventMark *mark_4 = [EventMark getEventMarkWithEvents:@[unit_10,unit_13]];
    mark_4.name = @&quot;第四阶段&quot;;
    
    [self push:mark_4];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;父类执行方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Objective-C&quot;&gt;// 开始执行
- (void)start {
    
    EventMark *events = [self pop];
    
    if (events) {
        
        [self excuteEvents:events];
        
    } else {
        // 所有事件执行完毕
        _currentEvents = nil;
        if ([self.delegate respondsToSelector:@selector(allEventsFinished)]) {
            [self.delegate allEventsFinished];
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-Objective-C&quot;&gt;// 执行事件
- (void)excuteEvents:(EventMark *)events{
    [self.lock lock];
    self.currentEvents = events;
    if ([self.delegate respondsToSelector:@selector(arriveOnEventSchedule:)]) {
        [self.delegate arriveOnEventSchedule:events];
    }
    [self.lock unlock];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在管理事件队列处，生成队列实例，创建队列，开启队列执行。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;    self.scheduleManager = [[ProductDetailSchedule alloc] init];  
    self.scheduleManager.delegate = self;  
    // 创建队列
    [self.scheduleManager createSchedule];  
    [self.scheduleManager start];
    
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;事件方法执行, 这里根据字符串转方法，在子线程异步执行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Objective-C&quot;&gt;- (void)arriveOnEventSchedule:(EventMark *)events{
    
    [events.events enumerateObjectsUsingBlock:^(EventUnit * _Nonnull obj, BOOL * _Nonnull stop) {
        
        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
                        
            SEL selector = NSSelectorFromString(obj.eventMethod);
            if ([self respondsToSelector:selector]) {
                
                IMP imp = [self methodForSelector:selector];
                void (*func)(id, SEL) = (void *)imp;
                func(self, selector);
            }
        });
    }];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/JumpJumpSparrow/EventScheduleManager.git&quot;&gt;Demo EventScheduleManager&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 18 Dec 2019 07:00:00 +0800</pubDate>
        <link>http://junziboxue.com/concurrent-events-queue</link>
        <guid isPermaLink="true">http://junziboxue.com/concurrent-events-queue</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>解决 H5 页面在手机上布局异常的问题</title>
        <description>&lt;p&gt;目前在做一款电商 APP，在商品详情页中，使用 webview 呈现 H5 内容来展现商品的图文详情。测试反馈说 H5 内容呈现样式发生异常，经研究是手机尺寸与PC尺寸存在差异，CSS 无法完全适配导致的。&lt;/p&gt;

&lt;p&gt;如图，图片显示不完整 ⤋
&lt;br /&gt;&lt;img src=&quot;/assets/images/iOS-webview-auto-scale/image_3.png&quot; width=&quot;200&quot; /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;把 URL string 放到PC上展示如下：⤋&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;img src=&quot;/assets/images/iOS-webview-auto-scale/image_5.png&quot; width=&quot;200&quot; /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;不难看出，这个详情页是把图片分割成多个部分，然后通过 CSS 布局拼接到一起的。&lt;/p&gt;

&lt;p&gt;拉伸 PC 浏览器窗口，可以看到我们想要的布局效果：⤋
&lt;br /&gt;&lt;img src=&quot;/assets/images/iOS-webview-auto-scale/image_4.png&quot; width=&quot;200&quot; /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot;&gt;// html 中，图片宽度为 750 px，
// 为了铺满屏幕，计算 initial-scale 初始缩放比例
// html 中的尺寸为 750, 手机使用的不是物理像素，而是点；
    
CGFloat w = [[UIScreen mainScreen] bounds].size.width;
CGFloat ratio = w/750.0;
&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;meta&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;charset=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'UTF-8'&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;meta&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'viewport'&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;content=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'width=device-width, initial-scale=1.0,minimum-scale=1.0, maximum-scale=1.0, user-scalable=0'&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;meta&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'format-detection'&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;content=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'telephone=no'&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;因为商品详情页在 PC 上的宽度为750像素， 我们根据手机频幕的宽度，计算出 H5 页面的缩放比例。&lt;br /&gt;
根据 H5 页面 头部 meta 信息，设置 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;initial-scale&lt;/code&gt;初始缩放比例，通过注入 JS 调整初始缩放比例&lt;/p&gt;

&lt;p&gt;加载页面之前，注入一段 JS 代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot;&gt;CGFloat w = [[UIScreen mainScreen] bounds].size.width;
CGFloat ratio = w/750.0;

NSString *jScript = @&quot;var meta = document.createElement('meta'); meta.setAttribute('name', 'viewport'); meta.setAttribute('content', 'width=device-width,initial-scale=ratio,minimum-scale=0.30, maximum-scale=3.0, user-scalable=0'); meta.setAttribute('content', 'width=device-width'); document.getElementsByTagName('head')[0].appendChild(meta);&quot;;

jScript = [jScript stringByReplacingOccurrencesOfString:@&quot;ratio&quot; withString:[NSString stringWithFormat:@&quot;%f&quot;,ratio]];

WKUserScript *wkUScript = [[WKUserScript alloc] initWithSource:jScript injectionTime:WKUserScriptInjectionTimeAtDocumentEnd forMainFrameOnly:YES];
WKUserContentController *wkUController = [[WKUserContentController alloc] init];
[wkUController addUserScript:wkUScript];

WKWebViewConfiguration *wkWebConfig = [[WKWebViewConfiguration alloc] init];
wkWebConfig.userContentController = wkUController;

wkWebV = [[WKWebView alloc] initWithFrame:self.view.frame configuration:wkWebConfig];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样，webview 跟据当前 屏幕大小，自适应缩放 H5页面的大小。&lt;/p&gt;

&lt;p&gt;设置比例过小的效果图 ⤋
&lt;br /&gt;&lt;img src=&quot;/assets/images/iOS-webview-auto-scale/image_2.png&quot; width=&quot;200&quot; /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;设置缩放比例正确的效果 ⤋&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/iOS-webview-auto-scale/image_1.png&quot; width=&quot;200&quot; /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/26295277/wkwebview-equivalent-for-uiwebviews-scalespagetofit&quot;&gt;参考链接&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 18 Dec 2019 07:00:00 +0800</pubDate>
        <link>http://junziboxue.com/scales-pagesize-to-fit</link>
        <guid isPermaLink="true">http://junziboxue.com/scales-pagesize-to-fit</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>关于自动驾驶伦理问题的思考</title>
        <description>&lt;p&gt;  在这里主要讨论自动驾驶技术的实际应用中，可能遇到的社会伦理问题以及相关思考。&lt;/p&gt;

&lt;p&gt;  目前市场上已经出现了可以自动驾驶的汽车，比如特斯拉、百度的阿波龙。 其中自动驾驶应用较为激进的当属特斯拉无疑。近几年 (2016-2018) 特斯拉的几起事故，可能与自动驾驶技术尚未完全成熟有关。而百度已获得全国首批T4道路测试牌照，自动驾达到L4级别的&lt;a href=&quot;http://apollo.auto/minibus/index_cn.html&quot;&gt;阿波龙&lt;/a&gt;已经于2018年7月4日正式量产下线，已经在多地开始展开试用。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/autopilot/apollo.jpg&quot; style=&quot;zoom:70%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;（图为阿波龙自动驾驶汽车）&lt;/p&gt;

&lt;p&gt;  随着人工智能 AI (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Artificial Intelligence&lt;/code&gt;) 的事件处理能力和数据分析精度变得更强更高，自动驾驶技术也开始进入了实用阶段。当然，实现自动驾驶除了 AI 必不可少以外，还需要&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;计算机视觉&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;高精度地图&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;5G高速通信技术&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;激光雷达&lt;/code&gt;等环境感知技术。可以预见到不久的将来，自动驾驶功能将会成为汽车的标配功能，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AI&lt;/code&gt; 也继 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;水&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;电&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;网络&lt;/code&gt;之后，势必成为生活中必不可少的基础元素，潜入到生活的方方面面。&lt;/p&gt;

&lt;p&gt;  然而 AI 作为自动驾驶的主要决策单元，代替驾驶员做出决策，控制车辆在道路上行走，这将带来一系列的社会伦理问题和法律问题。在这里列出一些自动驾驶在不久的将来可能会遇到的问题，与大家一起讨论、思考。&lt;/p&gt;

&lt;h4 id=&quot;问题1&quot;&gt;问题1&lt;/h4&gt;

&lt;p&gt;自动驾驶汽车行驶过程中，遇突发事故，选择避让可能危及行人生命安全，不避让可能会导致乘客伤亡，AI 该如何决策？&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/autopilot/user-innocent-accident.png&quot; style=&quot;zoom:70%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里有三个问题需要回答：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;用户&lt;/em&gt;&lt;/strong&gt;和&lt;strong&gt;&lt;em&gt;行人&lt;/em&gt;&lt;/strong&gt;都是无辜者，AI 有了干预的机会后，突来的意外应该降临到谁身上？&lt;/li&gt;
  &lt;li&gt;自动驾驶汽车作为一款产品，AI 是优先保护用户的安全？还是优先保护行人的安全？&lt;/li&gt;
  &lt;li&gt;遇到以上场景，自动驾驶是否需要&lt;strong&gt;&lt;em&gt;乘客&lt;/em&gt;&lt;/strong&gt;做出决策？或者说乘客的决定和AI的决定哪个有效？（自动驾驶里弱化了 司机 的角色，司机更多是 可以干预驾驶的乘客）&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;问题2&quot;&gt;问题2&lt;/h4&gt;

&lt;p&gt;一辆火车失控，即将撞向铁路上的五个人，这时 AI 可以控制扳手让火车转向，撞向另外一条轨道上的一个人。是将伤亡将到最小，还是让事故继续发生？&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/autopilot/which-one-to-choose.png&quot; style=&quot;zoom:70%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;人性、道德、法律，到底是谁做出了最终抉择？&lt;/p&gt;

&lt;p&gt;  这其实是美国哈佛大学政治哲学教授迈克尔·桑德尔，在公开课中设想的场景，用以描述行为选择的道德困境。在这里只是把人改为了 AI。在这里，不管 AI 如何处理，其最终决的选择实际来自于人，或者来自于人已经定制好的算法，AI 通过算法计算，忠实地执行了这个决定。&lt;/p&gt;

&lt;p&gt;  人可以为自己的决策和行为负责，那么AI的决策和行为谁来负责呢？&lt;/p&gt;

&lt;p&gt;  我认为这应该是社会群体层的共识问题，社会群体中的每个个体需要事先知晓 并接受 AI 的决策策略，在事故发生后， 所有人必须为算法的执行结果负责，因为这个是整个社会群体已经认可的选择。&lt;/p&gt;

&lt;p&gt;  当然 在现实中很难发生这种特殊情况，特别案例还需要根据实际情况具体分析，这里只是纯为讨论而假设的场景。&lt;/p&gt;

&lt;p&gt;自动驾驶不光光是 技术上的问题，法律和相关规范 是自动驾驶可以正常运行的必要条件。&lt;/p&gt;

&lt;p&gt;期待自动驾驶早点普及使用，在那之前，希望相关法律和规范已经落地执行。&lt;/p&gt;

&lt;p&gt;还有，没事不要到马路上溜达。&lt;/p&gt;

&lt;h3 id=&quot;end&quot;&gt;end&lt;/h3&gt;

&lt;p&gt;  写文章很有难度啊，写不下去了先在这里吐个槽，提升写作能力太有必要了。清楚明白地表达观点，并且让读者轻易的捕捉到你要表达的意思 ，让文章读起来感觉顺畅，同时保持整体有结构和层次，这些都不是那么容易的兼顾的到。想要提升写作能力，一番磨练必不可少啊。&lt;/p&gt;

&lt;p&gt;有问题或想法可以联系我讨论，邮箱：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;meowchunfat@hotmail.com&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;声明：本篇为个人原创，允许转载，转载请注明出处。&lt;/p&gt;
</description>
        <pubDate>Fri, 08 Nov 2019 00:00:00 +0800</pubDate>
        <link>http://junziboxue.com/auto-pilot-ethics</link>
        <guid isPermaLink="true">http://junziboxue.com/auto-pilot-ethics</guid>
        
        <category>something</category>
        
        
      </item>
    
      <item>
        <title>iOS 关于 UIView 重绘的几个接口</title>
        <description>&lt;p&gt;在更新数据时，往往伴随着更新 UI 布局。如何触发系统去刷新 UI 绘制呢？以下方法你需要了解一下。&lt;/p&gt;

&lt;h3 id=&quot;setneedslayout&quot;&gt;setNeedsLayout&lt;/h3&gt;
&lt;p&gt;Invalidates the current layout of the receiver and triggers a layout update during the next update cycle.&lt;br /&gt;
Call this method on your application’s main thread when you want to adjust the layout of a view’s subviews. This method makes a note of the request and returns immediately. Because this method does not force an immediate update, but instead waits for the next update cycle, you can use it to invalidate the layout of multiple views before any of those views are updated. This behavior allows you to consolidate all of your layout updates to one update cycle, which is usually better for performance.&lt;/p&gt;

&lt;h3 id=&quot;layoutifneeded&quot;&gt;layoutIfNeeded&lt;/h3&gt;
&lt;p&gt;Recalculate the receiver’s layout, if required.&lt;/p&gt;

&lt;p&gt;When this message is received, the layer’s super layers are traversed until a ancestor layer is found that does not require layout. Then layout is performed on the entire layer-tree beneath that ancestor.&lt;/p&gt;

&lt;h3 id=&quot;layoutsubviews&quot;&gt;layoutSubviews&lt;/h3&gt;

&lt;p&gt;The default implementation of this method does nothing on iOS 5.1 and earlier. Otherwise, the default implementation uses any constraints you have set to determine the size and position of any subviews.&lt;/p&gt;

&lt;p&gt;Subclasses can override this method as needed to perform more precise layout of their subviews. You should override this method only if the autoresizing and constraint-based behaviors of the subviews do not offer the behavior you want. You can use your implementation to set the frame rectangles of your subviews directly.&lt;/p&gt;

&lt;p&gt;You should not call this method directly. If you want to force a layout update, call the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setNeedsLayout&lt;/code&gt; method instead to do so prior to the next drawing update. If you want to update the layout of your views immediately, call the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;layoutIfNeeded&lt;/code&gt; method.&lt;/p&gt;

&lt;h3 id=&quot;setneedsdisplay&quot;&gt;setNeedsDisplay&lt;/h3&gt;

&lt;p&gt;Recalculate the receiver’s layout, if required.&lt;br /&gt;
When this message is received, the layer’s super layers are traversed until a ancestor layer is found that does not require layout. Then layout is performed on the entire layer-tree beneath that ancestor.&lt;/p&gt;
</description>
        <pubDate>Fri, 18 Oct 2019 00:00:00 +0800</pubDate>
        <link>http://junziboxue.com/UIView-drawing-cycle</link>
        <guid isPermaLink="true">http://junziboxue.com/UIView-drawing-cycle</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>iOS Emoji 过滤</title>
        <description>&lt;p&gt;  因为 emoji 字符在转码或存入数据库时，会遇到一些异常，因此在开发过程中，有过滤 emoji 或者禁止输入 emoji 的需求。&lt;/p&gt;

&lt;h3 id=&quot;什么是-emoji-&quot;&gt;什么是 emoji ？&lt;/h3&gt;
&lt;p&gt;  emoji 最早是由日本人&lt;em&gt;栗田穰崇&lt;/em&gt; (Shigetaka Kurita)创作的。emoji 是一些图形符号，例如：😊👏🚗🌞。和普通文字符号不同，emoji 通过一些图案来表达一些辨识度较高的场景或者含义，使阅读体验更好。在此可以查找各种 emoji &lt;a href=&quot;https://emojipedia.org&quot;&gt;emojipedia&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;(未完待续)d&lt;/p&gt;
</description>
        <pubDate>Sun, 13 Oct 2019 01:00:00 +0800</pubDate>
        <link>http://junziboxue.com/emoji-filter</link>
        <guid isPermaLink="true">http://junziboxue.com/emoji-filter</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>Building Objective-C static libraries with categories</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;Q:  How do I fix “selector not recognized” runtime exceptions when trying to use category methods from a static library?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如何解决 在 runtime 环境中尝试调用静态库中分类的方法时，报 “selector not recognized” 异常？&lt;/p&gt;

&lt;p&gt;  今天在浏览 YYKit 库时，一个宏定义引起了我的注意：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;YYSYNTH_DUMMY_CLASS &lt;/code&gt;,从字面意思看是定义了一个不起任何作用的&lt;em&gt;哑&lt;/em&gt;类。相关描述如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Objective-C&quot;&gt;/**
 Add this macro before each category implementation, so we don't have to use
 -all_load or -force_load to load object files from static libraries that only
 contain categories and no classes.
 More info: http://developer.apple.com/library/mac/#qa/qa2006/qa1490.html .
 *******************************************************************************
 Example:
     YYSYNTH_DUMMY_CLASS(NSString_YYAdd)
 */
#ifndef YYSYNTH_DUMMY_CLASS
#define YYSYNTH_DUMMY_CLASS(_name_) \
@interface YYSYNTH_DUMMY_CLASS_ ## _name_ : NSObject @end \
@implementation YYSYNTH_DUMMY_CLASS_ ## _name_ @end
#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  根据 YYKit 作者的描述，在分类中加一个这样的宏定义可以避免一些复杂操作，具体原理作者并没有解释，只是给了一个苹果官方开发文档的连接。这个链接可能因为官方整理文档的原因，URL路径已经失效了。但是在官网搜索 URL 中的关键字找到了这篇&lt;a href=&quot;https://developer.apple.com/library/archive/qa/qa1490/_index.html&quot;&gt;资料&lt;/a&gt;。根据这篇资料在这里深入了解一下其中的原理和如何解决这类问题。&lt;/p&gt;

&lt;p&gt;官方文档以一个问题开篇，就是上面提出的那个问题，哈哈。接下来官方文档就给出了问题的解决方法：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;A: If you’re seeing a “selector not recognized” runtime exception when calling a category method that is implemented in a static library, you are hitting the link-time build issue described here, and need to add the -ObjC linker flag to your project, by following these steps:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;In Xcode, choose View &amp;gt; Navigators &amp;gt; Show Project Navigator, or press ⌘1.&lt;/li&gt;
    &lt;li&gt;Select your project under the PROJECT heading in the Project Navigator, then select the Build Settings tab.&lt;/li&gt;
    &lt;li&gt;Scroll down to the Other Linker Flags build setting under the Linking collection, or type “Other Linker Flags” into the search bar.&lt;/li&gt;
    &lt;li&gt;Set the value of the Other Linker Flags build setting to $(OTHER_LDFLAGS) -ObjC.&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;译：当你在运行时调用一个在静态库中实现的分类的方法时，遇到 “selector not recognized” 运行时异常，那么你就撞到了本篇文档中描述的所谓的 “the link-time build issue” 问题，同时你需要在你的工程中加上 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-ObjC linker flag&lt;/code&gt; 来解决这个问题。具体步骤：(在这里就不翻译了么么哒)。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Figure 1:&lt;/em&gt;  Modifying the Other Linker Flags build setting.    &lt;br /&gt;
&lt;br /&gt;&lt;img src=&quot;/assets/article_assets/qa1490_other_linker_flags_xcode_5.png&quot; /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;h3 id=&quot;troubleshooting&quot;&gt;Troubleshooting&lt;/h3&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;If adding the -ObjC flag isn’t fixing the problem, double check that a conflicting Target build setting is not overriding it, by following the above steps, but selecting the current target under “TARGETS” in step 2, instead of the project.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;解决问题&quot;&gt;解决问题&lt;/h3&gt;
&lt;p&gt;  如果添加&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-ObjC flag&lt;/code&gt;没能解决这个问题，检查一下确保之前的操作没有与 Target build setting 冲突而使其无效。按照上面的步骤，在第二步时选择 &lt;em&gt;“TARGETS”&lt;/em&gt;下的target，而不是选择 project。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;h3 id=&quot;other-causes-of-selector-not-recognized-exceptions&quot;&gt;Other Causes of selector not recognized Exceptions&lt;/h3&gt;
  &lt;p&gt;The most common causes of a “selector not recognized” exception are:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;h3 id=&quot;no-such-method&quot;&gt;No Such Method&lt;/h3&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;The method really does not exist. Check your spelling. Check documentation to verify that the method exists on the version of the operating system your app is using.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;h3 id=&quot;memory-management&quot;&gt;Memory Management&lt;/h3&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Your app is trying to use an object after it has been deallocated, use the Zombies instrument to debug this kind of problem. You are seeing “selector not recognized” because the memory has been re-allocated as a different kind of object.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;导致selector-not-recognized-exceptions异常的其他原因&quot;&gt;导致&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;selector not recognized Exceptions&lt;/code&gt;异常的其他原因&lt;/h3&gt;
&lt;p&gt;  导致&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;selector not recognized Exceptions&lt;/code&gt;异常的原因通常是：&lt;/p&gt;
&lt;h4 id=&quot;方法不存在&quot;&gt;方法不存在&lt;/h4&gt;
&lt;p&gt;  方法实际上是不存在的。检查你的拼写是否有误。查阅文档，确保你调用的方法在当前版本的操作系统内存在。&lt;/p&gt;
&lt;h4 id=&quot;内存管理&quot;&gt;内存管理&lt;/h4&gt;
&lt;p&gt;  在对象已释放后，你的应用又尝试去访问它，原先存放对象的内存已被重新分配给其他类的对象，所以当你再次访问原先的对象时，就会发生 “selector not recognized”异常。使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Zombies instrument&lt;/code&gt;工具来debug这类问题。（这一段文档不通顺，稍作整理）&lt;/p&gt;

&lt;blockquote&gt;
  &lt;h2 id=&quot;what-causes-those-exceptions&quot;&gt;What causes those exceptions?&lt;/h2&gt;
  &lt;p&gt;An impedance mismatch between UNIX static libraries and the dynamic nature of Objective-C can cause category methods in static libraries to not be linked into an app, resulting in “selector not recognized” exceptions when the methods aren’t found at runtime.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;导致这些异常的原因&quot;&gt;导致这些异常的原因&lt;/h2&gt;
&lt;p&gt;由于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UNIX static libraries&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dynamic nature of Objective-C&lt;/code&gt;不是很搭的原因，导致静态库中分类的方法不会被链接到app中去，以至于在 runtime 动态调用时无法找到方法，结果发生 “selector not recognized”异常。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;h3 id=&quot;the-linker&quot;&gt;The Linker&lt;/h3&gt;
  &lt;p&gt;When a C program is compiled, each “source file” is turned into an “object file” that contains executable functions and static data. The linker glues these object files together into a final executable. That executable is eventually bundled into an app by Xcode.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;链接器&quot;&gt;链接器&lt;/h3&gt;
&lt;p&gt;当一个 C 程序被编译完成，所有”原文件”都被转换为”object file”，这些”object file”包含可执行方法和静态数据。链接器将这些”object file”粘合在一起，最终成为可执行文件。最终 Xcode 将这些可执行文件打包进APP中。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;When a source file uses something (like a function) defined in another file, then an undefined symbol is written into the object file, to “stand in” for the missing thing. The linker resolves these symbols by pulling in the object files that include definitions of undefined symbols when building the final executable.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;当一个原文件调用某些在其他文件中定义的方法或者数据时，那么一个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;未经定义的符号&lt;/code&gt;就被写入了 “object file”,用以代替缺失的方法或数据。在组成最终可执行文件时，链接器从那些包含 “undefined symbols” 定义的 “object files” 中抽取定义来解析这些符号。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;For example, if main.c uses the function foo(), where foo is defined in another file, B.c, then the object file main.o will have an unresolved symbol for foo(), and B.o will include an implementation of foo(). At link time, B.o will be brought into the final executable, so that the code in main.o now references the implementation of foo() defined in B.o.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;举个例子，假如 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main.c&lt;/code&gt; 调用方法 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;foo()&lt;/code&gt;,而 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;foo&lt;/code&gt; 函数是在另一个文件 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;B.c&lt;/code&gt; 中定义的，那么 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;object file main.o&lt;/code&gt; 将会有一个未解析符号表示 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;foo()&lt;/code&gt;，同时 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;B.o&lt;/code&gt; 将会包含 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;foo()&lt;/code&gt; 方法实现。在链接阶段，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;B.o&lt;/code&gt; 将会被带入 最终执行文件，因此现在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main.o&lt;/code&gt; 中的代码就可以引用在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;B.o&lt;/code&gt; 中对 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;foo()&lt;/code&gt; 的实现。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;A UNIX static library is just a collection of object files. Normally the linker only pulls in an object file from a static library if doing so would resolve some undefined symbol. Not pulling in all object files reduces the size of the final executable.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UNIX static library&lt;/code&gt; 只是将 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;object files&lt;/code&gt; 集合在一起。链接器通常只会从&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;static library&lt;/code&gt;中提取那些包含&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;undefined symbol&lt;/code&gt;解析的 object file，而不是把所有 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;object files&lt;/code&gt; 都集成进来。这样可以减小最终可执行文件的体积。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;h3 id=&quot;objective-c&quot;&gt;Objective-C&lt;/h3&gt;
  &lt;p&gt;The dynamic nature of Objective-C complicates things slightly. Because the code that implements a method is not determined until the method is actually called, Objective-C does not define linker symbols for methods. Linker symbols are only defined for classes.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;objective-c-1&quot;&gt;Objective-C&lt;/h3&gt;

&lt;p&gt;O-C 的动态特性使这个过程略微复杂了一些。因为实现一个方法的代码直到这个方法被调用时才会被确定下来。Objective-C 并不为方法定义链接符号，链接符号只为 &lt;em&gt;类&lt;/em&gt; 进行定义。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;For example, if main.m includes the code [[FooClass alloc] initWithBar:nil]; then main.o will contain an undefined symbol for FooClass, but no linker symbols for the -initWithBar: method will be in main.o.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;比如： 假如 main.m 包含了这样的代码：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[[FooClass alloc] initWithBar:nil];&lt;/code&gt;,那么 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main.o&lt;/code&gt; 将会包含一个未定义符号表示 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FooClass&lt;/code&gt;，但是在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main.o&lt;/code&gt; 文件中，并不生成链接符号去表示 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-initWithBar:&lt;/code&gt; 方法。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Since categories are a collection of methods, using a category’s method does not generate an undefined symbol. This means the linker does not know to load an object file defining the category, if the class itself is already defined. This causes the same “selector not recognized” runtime exception you would see for any unimplemented method.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;因为分类是一组方法的集合，假如一个类已经定义了，在其中使用分类的方法并不生成 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;undefined symbol&lt;/code&gt;,这意味着链接器不知道需要去加载对应的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;object file&lt;/code&gt; 去定义分类。调用任何未实现的方法也一样会导致 “selector not recognized” 运行时异常。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;###The -ObjC Linker Flag
Passing the -ObjC option to the linker causes it to load all members of static libraries that implement any Objective-C class or category. This will pickup any category method implementations. But it can make the resulting executable larger, and may pickup unnecessary objects. For this reason it is not on by default.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;the--objc-linker-flag&quot;&gt;The -ObjC Linker Flag&lt;/h3&gt;
&lt;p&gt;指定 链接器的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-ObjC&lt;/code&gt; 选项 可以使 链接器加载所有静态库总的成员，包括 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Objective-C&lt;/code&gt; 的类和分类。这将选入所有分类方法的实现。同时也使最最终的可执行文件体积更大，这也是为什么不作为默认选项。&lt;/p&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;YYKit 中的这个宏定义在 分类之前加了一个空类，这样&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.m&lt;/code&gt;文件就包含了类，这样生成的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.o&lt;/code&gt;文件就会被链接器打包进最终的可执行文件，从而避免了 “selector not recognized”异常的出现。&lt;/p&gt;

</description>
        <pubDate>Wed, 25 Sep 2019 02:00:00 +0800</pubDate>
        <link>http://junziboxue.com/yykit-micro</link>
        <guid isPermaLink="true">http://junziboxue.com/yykit-micro</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>UITextField 随键盘高度自适应</title>
        <description>&lt;p&gt;  在开发APP过程中，不免会遇到页面需要多个 UITextField 的需求，那么问题来了：当输入框过多时，弹起键盘会遮盖住输入框，或者需要依次点击输入框才能输入。用户的输入体验非常差。为解决这个问题，我们让输入框跟随键盘自动调整高度，并且点击回车键自动跳转到下一个输入框进行输入。&lt;/p&gt;

&lt;p&gt;具体效果如图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/auto-adjust-height-textfield/auto-adjust-height-textfield.gif&quot; /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;需求分析&quot;&gt;需求分析：&lt;/h3&gt;
&lt;p&gt;  简单分析一下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;点击输入框时，输入框随着键盘弹起，自动调整高度，使输入框位于键盘上方。&lt;/li&gt;
  &lt;li&gt;点击回车，自动切换到下一个输入框进行输入，同时调整输入框高度。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;为了使输入框能够上下滑动，这里将所有 UITextField 放在一个 scrollview 上，然后添加键盘监听事件，当用户点击输入框时，触发键盘弹起，此时调整scrollView 的 contentOffset，使输入框正好位于键盘上方。&lt;/p&gt;

&lt;h4 id=&quot;添加键盘监听&quot;&gt;添加键盘监听：&lt;/h4&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt; [[NSNotificationCenter defaultCenter]addObserver:self selector:@selector(keyboardWillShow:) name:UIKeyboardWillShowNotification object:nil];
 [[NSNotificationCenter defaultCenter]addObserver:self selector:@selector(keyboardWillHide:) name:UIKeyboardWillHideNotification object:nil];
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;键盘响应事件&quot;&gt;键盘响应事件：&lt;/h4&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt; - (void)keyboardWillShow:(NSNotification *)notification {
    //获取键盘高度，在不同设备上，以及中英文下是不同的
    CGFloat kbHeight = [[notification.userInfo objectForKey:UIKeyboardFrameEndUserInfoKey] CGRectValue].size.height;
    _keyBoardHeight = kbHeight;
    [self boardAutoAdjust:kbHeight];
}

&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt; - (void)keyboardWillHide:(NSNotification *)notify {
    // 键盘动画时间
    _keyBoardHeight = 0;
    [self.board setContentOffset:CGPointMake(0,-64) animated:YES];
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;uitextfield-代理事件&quot;&gt;UITextField 代理事件：&lt;/h4&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt; - (BOOL)textFieldShouldBeginEditing:(UITextField *)textField {
    
    NSLog(@&quot;=== %@&quot;, [NSValue valueWithCGRect:textField.frame]);
    self.fistField = textField;
    
    if (_keyBoardHeight &amp;gt; 0) {
        [self boardAutoAdjust:_keyBoardHeight];
    }
    return YES;
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;scrollview-偏移量计算&quot;&gt;scrollview 偏移量计算&lt;/h4&gt;
&lt;p&gt;  scrollView 需要偏移的量 =&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;页面总高度&lt;/code&gt; - &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;输入框高度&lt;/code&gt; - &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;键盘高度&lt;/code&gt;,当输入框高于键盘时，偏移量小于零，反之，偏移量大于零。 
&lt;br /&gt;
&lt;img width=&quot;200&quot; src=&quot;/assets/images/auto-adjust-height-textfield/mark-line.png&quot; /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;偏移量计算方法：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;- (void)boardAutoAdjust:(CGFloat)keyboardHeight {
    
    if (self.fistField) {
        
        CGRect rec = _fistField.frame;
        
        CGFloat max_y = CGRectGetMaxY(rec);
        
        CGFloat b_offset = self.view.height - max_y - keyboardHeight;
        
        CGPoint point = self.board.contentOffset;
        point.y = -b_offset;
        
        [self.board setContentOffset:point animated:YES];
    }
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;键盘回车事件&quot;&gt;键盘回车事件&lt;/h4&gt;

&lt;p&gt;  当点击键盘回车时，自动跳转到下一个输入框进行输入，最后一个输入框点击回车时，收起键盘，整体回到原先的布局高度。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;- (BOOL)textFieldShouldReturn:(UITextField *)textField {
    
    if (textField.returnKeyType == UIReturnKeyNext) {
        
        [textField resignFirstResponder];
        UITextField *next = [self.textfields objectAtIndex:(textField.tag + 1)];
        [next becomeFirstResponder];
        
    } else if (textField.returnKeyType == UIReturnKeyDone) {
        
        [textField resignFirstResponder];
    }
    
    return YES;;
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/JumpJumpSparrow/DemoCollection.git&quot;&gt;demo链接&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 23 Sep 2019 22:00:00 +0800</pubDate>
        <link>http://junziboxue.com/textfield-auto-adjust</link>
        <guid isPermaLink="true">http://junziboxue.com/textfield-auto-adjust</guid>
        
        <category>iOS</category>
        
        
      </item>
    
  </channel>
</rss>
