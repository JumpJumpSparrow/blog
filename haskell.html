<!DOCTYPE html>
<html>
<head>

    <!-- Document Settings -->
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    <!-- Base Meta -->
    <!-- dynamically fixing the title for tag/author pages -->



    <title>Haskell 函数式编程</title>
    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- Styles'n'Scripts -->
    <link rel="stylesheet" type="text/css" href="/assets/built/screen.css" />
    <link rel="stylesheet" type="text/css" href="/assets/built/screen.edited.css" />
    <link rel="stylesheet" type="text/css" href="/assets/built/syntax.css" />
    <!-- highlight.js -->
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css">
    <style>.hljs { background: none; }</style>

    <!--[if IE]>
        <style>
            p, ol, ul{
                width: 100%;
            }
            blockquote{
                width: 100%;
            }
        </style>
    <![endif]-->
    
    <!-- This tag outputs SEO meta+structured data and other important settings -->
    <meta name="description" content="Cloud in the sky, fish in the river" />
    <link rel="shortcut icon" href="http://localhost:4000/assets/images/favicon.png" type="image/png" />
    <link rel="canonical" href="http://localhost:4000/haskell" />
    <meta name="referrer" content="no-referrer-when-downgrade" />

     <!--title below is coming from _includes/dynamic_title-->
    <meta property="og:site_name" content="Miaocf" />
    <meta property="og:type" content="website" />
    <meta property="og:title" content="Haskell 函数式编程" />
    <meta property="og:description" content="Haskell 与 Java、C++不同，它是纯函数式的编程语言，说到函数式编程，函数式与面向对象编程究竟有哪些不同？在这里将会介绍一下函数式编程的特点和起源。 编程范式： 在介绍 Haskell 之前，说一说编程范式，编程范式可简单划为两类： 命令式编程 (Imperative programming) 声明式编程(Declarative programming) 命令式编程 （Imperative programming） 将程序写成一条条指令，计算机依次执行得到最终结果，这种编写程序的方式叫做 命令式编程。 通常包含三种基本语句： 运算语句 循环语句 流程控制语句 结构化命令式 -&gt; 面向对象编程（Object-oriented programming，OOP） 一种软件设计思想，OOP达到了软件工程的三个主要目标：重用性、灵活性和扩展性。OOP=对象+类+继承+多态+消息，其中核心概念是类和对象。 声明式编程（Declarative programming） 声明式编程的发源 声明式编程发轫于人工智能的研究，主要包括函数式编程（functional programming，简称FP）和逻辑式编程（logic programming，简称LP）。 其中，函数式编程将计算描述为数学函数的求值，而逻辑式编程通过提供一系列事实和规则来推导或论证结论。 声明式编程是人脑思维方式的抽象，即利用数理逻辑或既定规范对已知条件进行推理或运算。声明式描述目标的性质，让计算机明白目标，而非流程。 声明式与命令式编程理念和风格 命令式编程是行动导向（Action-Oriented）的，因而算法是显性而目标是隐性的； 声明式编程是目标驱动（Goal-Driven）的，因而目标是显性而算法是隐性的。 常见的命令式编程语言有：C、C++、Objecti-C、Java、PHP 等等，其中有些也可以支持 声明式编程。 常见的声明式编程语言有：SQL、HTML、Haskell、Lisp、Prolog。 什么是 Haskell Haskell 与其他语言不同，是一门纯粹函数式编程语言 (purely functional programming language) 在纯粹函数式编程语言中，不是像命令式语言那样命令电脑「要做什么」，而是通过用函数来描述出问题「是什么」，" />
    <meta property="og:url" content="http://localhost:4000/haskell" />
    <meta property="og:image" content="http://localhost:4000/assets/images/writing.jpg" />
    <meta property="article:publisher" content="https://www.facebook.com/false" />
    <meta property="article:author" content="https://www.facebook.com/false" />
    <meta property="article:published_time" content="2019-06-10T18:00:00+08:00" />
    <meta property="article:modified_time" content="2019-06-10T18:00:00+08:00" />
    <meta property="article:tag" content="Functional" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="Haskell 函数式编程" />
    <meta name="twitter:description" content="Haskell 与 Java、C++不同，它是纯函数式的编程语言，说到函数式编程，函数式与面向对象编程究竟有哪些不同？在这里将会介绍一下函数式编程的特点和起源。 编程范式： 在介绍 Haskell 之前，说一说编程范式，编程范式可简单划为两类： 命令式编程 (Imperative programming) 声明式编程(Declarative programming) 命令式编程 （Imperative programming） 将程序写成一条条指令，计算机依次执行得到最终结果，这种编写程序的方式叫做 命令式编程。 通常包含三种基本语句： 运算语句 循环语句 流程控制语句 结构化命令式 -&gt; 面向对象编程（Object-oriented programming，OOP） 一种软件设计思想，OOP达到了软件工程的三个主要目标：重用性、灵活性和扩展性。OOP=对象+类+继承+多态+消息，其中核心概念是类和对象。 声明式编程（Declarative programming） 声明式编程的发源 声明式编程发轫于人工智能的研究，主要包括函数式编程（functional programming，简称FP）和逻辑式编程（logic programming，简称LP）。 其中，函数式编程将计算描述为数学函数的求值，而逻辑式编程通过提供一系列事实和规则来推导或论证结论。 声明式编程是人脑思维方式的抽象，即利用数理逻辑或既定规范对已知条件进行推理或运算。声明式描述目标的性质，让计算机明白目标，而非流程。 声明式与命令式编程理念和风格 命令式编程是行动导向（Action-Oriented）的，因而算法是显性而目标是隐性的； 声明式编程是目标驱动（Goal-Driven）的，因而目标是显性而算法是隐性的。 常见的命令式编程语言有：C、C++、Objecti-C、Java、PHP 等等，其中有些也可以支持 声明式编程。 常见的声明式编程语言有：SQL、HTML、Haskell、Lisp、Prolog。 什么是 Haskell Haskell 与其他语言不同，是一门纯粹函数式编程语言 (purely functional programming language) 在纯粹函数式编程语言中，不是像命令式语言那样命令电脑「要做什么」，而是通过用函数来描述出问题「是什么」，" />
    <meta name="twitter:url" content="http://localhost:4000/" />
    <meta name="twitter:image" content="http://localhost:4000/assets/images/writing.jpg" />
    <meta name="twitter:label1" content="Written by" />
    <meta name="twitter:data1" content="Miaocf" />
    <meta name="twitter:label2" content="Filed under" />
    <meta name="twitter:data2" content="Functional" />
    <meta name="twitter:site" content="@false" />
    <meta name="twitter:creator" content="@false" />
    <meta property="og:image:width" content="1400" />
    <meta property="og:image:height" content="933" />

    <script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Website",
    "publisher": {
        "@type": "Organization",
        "name": "Miaocf",
        "logo": "http://localhost:4000/assets/images/blog-icon.png"
    },
    "url": "http://localhost:4000/haskell",
    "image": {
        "@type": "ImageObject",
        "url": "http://localhost:4000/assets/images/writing.jpg",
        "width": 2000,
        "height": 666
    },
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "http://localhost:4000/haskell"
    },
    "description": "Haskell 与 Java、C++不同，它是纯函数式的编程语言，说到函数式编程，函数式与面向对象编程究竟有哪些不同？在这里将会介绍一下函数式编程的特点和起源。 编程范式： 在介绍 Haskell 之前，说一说编程范式，编程范式可简单划为两类： 命令式编程 (Imperative programming) 声明式编程(Declarative programming) 命令式编程 （Imperative programming） 将程序写成一条条指令，计算机依次执行得到最终结果，这种编写程序的方式叫做 命令式编程。 通常包含三种基本语句： 运算语句 循环语句 流程控制语句 结构化命令式 -&gt; 面向对象编程（Object-oriented programming，OOP） 一种软件设计思想，OOP达到了软件工程的三个主要目标：重用性、灵活性和扩展性。OOP=对象+类+继承+多态+消息，其中核心概念是类和对象。 声明式编程（Declarative programming） 声明式编程的发源 声明式编程发轫于人工智能的研究，主要包括函数式编程（functional programming，简称FP）和逻辑式编程（logic programming，简称LP）。 其中，函数式编程将计算描述为数学函数的求值，而逻辑式编程通过提供一系列事实和规则来推导或论证结论。 声明式编程是人脑思维方式的抽象，即利用数理逻辑或既定规范对已知条件进行推理或运算。声明式描述目标的性质，让计算机明白目标，而非流程。 声明式与命令式编程理念和风格 命令式编程是行动导向（Action-Oriented）的，因而算法是显性而目标是隐性的； 声明式编程是目标驱动（Goal-Driven）的，因而目标是显性而算法是隐性的。 常见的命令式编程语言有：C、C++、Objecti-C、Java、PHP 等等，其中有些也可以支持 声明式编程。 常见的声明式编程语言有：SQL、HTML、Haskell、Lisp、Prolog。 什么是 Haskell Haskell 与其他语言不同，是一门纯粹函数式编程语言 (purely functional programming language) 在纯粹函数式编程语言中，不是像命令式语言那样命令电脑「要做什么」，而是通过用函数来描述出问题「是什么」，"
}
    </script>

    <!-- <script type="text/javascript" src="https://demo.ghost.io/public/ghost-sdk.min.js?v=724281a32e"></script>
    <script type="text/javascript">
    ghost.init({
    	clientId: "ghost-frontend",
    	clientSecret: "f84a07a72b17"
    });
    </script> -->

    <meta name="generator" content="Jekyll 3.6.2" />
    <link rel="alternate" type="application/rss+xml" title="Haskell 函数式编程" href="/feed.xml" />


</head>
<body class="post-template">

    <div class="site-wrapper">
        <!-- All the main content gets inserted here, index.hbs, post.hbs, etc -->
        <!-- default -->

<!-- The tag above means: insert everything in this file
into the {body} of the default.hbs template -->

<header class="site-header outer">
    <div class="inner">
        <nav class="site-nav">
    <div class="site-nav-left">
        
            
                <a class="site-nav-logo" href="http://localhost:4000/"><img src="/assets/images/blog-icon.png" alt="Miaocf" /></a>
            
        
        
            <ul class="nav" role="menu">
    <li class="nav-home" role="menuitem"><a href="/">Home</a></li>
    <li class="nav-about" role="menuitem"><a href="/about/">About</a></li>
    <li class="nav-getting-started" role="menuitem"><a href="/tag/getting-started/">Getting Started</a></li>
    <li class="nav-try-ghost" role="menuitem"><a href="https://ghost.org">Try Ghost</a></li>
</ul>

        
    </div>
    <div class="site-nav-right">
        <div class="social-links">
            
            
        </div>
        
    </div>
</nav>

    </div>
</header>

<!-- Everything inside the #post tags pulls data from the post -->
<!-- #post -->

<main id="site-main" class="site-main outer" role="main">
    <div class="inner">

        <article class="post-full post tag-functional ">

            <header class="post-full-header">
                <section class="post-full-meta">
                    <time class="post-full-meta-date" datetime="10 June 2019">10 June 2019</time>
                    
                        <span class="date-divider">/</span>
                        
                            
                               <a href='/tag/functional/'>FUNCTIONAL</a>
                            
                        
                    
                </section>
                <h1 class="post-full-title">Haskell 函数式编程</h1>
            </header>

            
            <figure class="post-full-image" style="background-image: url(/assets/images/writing.jpg)">
            </figure>
            

            <section class="post-full-content">
                <div class="kg-card-markdown">
                    <p>Haskell 与 Java、C++不同，它是纯函数式的编程语言，说到函数式编程，函数式与面向对象编程究竟有哪些不同？在这里将会介绍一下函数式编程的特点和起源。</p>

<p><img src="assets/images/defineHaskell.png" alt="" /></p>

<h3 id="编程范式">编程范式：</h3>
<p>在介绍 Haskell 之前，说一说编程范式，编程范式可简单划为两类：</p>
<ul>
  <li>命令式编程 (Imperative programming)</li>
  <li>声明式编程(Declarative programming)</li>
</ul>

<ol>
  <li>命令式编程 （Imperative programming）<br />
将程序写成一条条指令，计算机依次执行得到最终结果，这种编写程序的方式叫做 命令式编程。
通常包含三种基本语句：
    <ul>
      <li>运算语句</li>
      <li>循环语句</li>
      <li>流程控制语句</li>
    </ul>
  </li>
</ol>

<p><em>结构化命令式</em>  -&gt; 面向对象编程（Object-oriented programming，OOP）
一种软件设计思想，OOP达到了软件工程的三个主要目标：重用性、灵活性和扩展性。OOP=对象+类+继承+多态+消息，其中核心概念是类和对象。</p>

<ol>
  <li>声明式编程（Declarative programming）</li>
</ol>

<p>声明式编程的发源
  声明式编程发轫于人工智能的研究，主要包括函数式编程（functional programming，简称FP）和逻辑式编程（logic programming，简称LP）。
其中，函数式编程将计算描述为数学函数的求值，而逻辑式编程通过提供一系列事实和规则来推导或论证结论。
声明式编程是人脑思维方式的抽象，即利用数理逻辑或既定规范对已知条件进行推理或运算。声明式描述目标的性质，让计算机明白目标，而非流程。</p>

<h4 id="声明式与命令式编程理念和风格">声明式与命令式编程理念和风格</h4>

<ul>
  <li>命令式编程是行动导向（Action-Oriented）的，因而算法是显性而目标是隐性的；</li>
  <li>声明式编程是目标驱动（Goal-Driven）的，因而目标是显性而算法是隐性的。</li>
</ul>

<p>常见的命令式编程语言有：C、C++、Objecti-C、Java、PHP 等等，其中有些也可以支持 声明式编程。
常见的声明式编程语言有：SQL、HTML、Haskell、Lisp、Prolog。</p>

<h3 id="什么是-haskell">什么是 Haskell</h3>

<p>Haskell 与其他语言不同，是一门纯粹函数式编程语言 (purely functional programming language)</p>

<p>在纯粹函数式编程语言中，不是像命令式语言那样命令电脑「要做什么」，而是通过用函数来描述出问题「是什么」，
如「阶乘是指从1到某个数的乘积」，「一个串列中数字的和」是指把第一个数字跟剩余数字的和相加。
用声明函数是什么的形式来写程序。另外，变量 (variable) 一旦被指定，就不可以更改了，
已经说了 a 就是 5，就不能再另说 a 是别的什么数。</p>

<h4 id="haskell-的特点">Haskell 的特点</h4>
<ol>
  <li>Haskell 是惰性 (lazy) 的。也就是说若非特殊指明，函数在真正需要结果以前不会被求值.</li>
  <li>Haskell 是静态类型 (statically typed) 的。当你编译程序时，编译器需要明确哪个是数字，哪个是字符串。</li>
</ol>

<p>纯度</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>函数带有副作用指的是，函数的行为受系统的全局状态所影响。

举个命令式语言的例子：假设有某个函数，它读取并返回某个全局变量，如果程序中的其他代码可以修改这个全局变量的话，
那么这个函数的返回值就取决于这个全局变量在某一时刻的值。我们说这个函数带有副作用，尽管它并不亲自修改全局变量。

副作用本质上是函数的一种不可见的（invisible）输入或输出。
Haskell 的函数在默认情况下都是无副作用的：函数的结果只取决于显式传入的参数。
我们将带副作用的函数称为'不纯（impure）函数'，而将不带副作用的函数称为'纯（pure）函数'。
 
</code></pre></div></div>
<h3 id="安装运行-haskell-脚本">安装运行 Haskell 脚本：</h3>

<ol>
  <li>到 ‘www.haskell.org’ 官网按照提示安装编译器 GHC，</li>
  <li>GHC 可以解释运行 HasKell 脚本，也可以编译。它还提供一个’交互模式’ 加载 Haskell 脚本，然后调用脚本里的函数</li>
  <li>新建脚本文件，以’.hs’结尾， 打开控制台输入 ghci，进入交互模式。</li>
  <li>运行 ‘:l xxx.hs’ 加载脚本，如果更新文件需 运行 ‘:r xxx.hs’</li>
</ol>

<h3 id="haskell-函数式表达">Haskell 函数式表达</h3>

<h4 id="haskell-中的-list">Haskell 中的 List</h4>

<p>List 是一种单类型的数据结构，可以用来存储多个类型相同的元素。List 中的 List 可以是不同长度，但必须得是相同的类型.</p>

<p>字符串是一组字符的 List，<code class="highlighter-rouge">"Hello"</code> 是 <code class="highlighter-rouge">['h','e','l','l','o']</code> 的语法糖。可以使用处理 List 的函数来对字符串进行操作。 将两个 List 合并，可以通过 <code class="highlighter-rouge">++</code> 运算符实现。
  <code class="highlighter-rouge">:</code> 运算符可以连接一个元素到一个 List之中，而 <code class="highlighter-rouge">++</code> 运算符则是连接两个 List。若要使用 <code class="highlighter-rouge">++</code> 运算符连接单个元素到一个 List 之中，就用方括号把它括起使之成为单个元素的 List。<code class="highlighter-rouge">[1,2,3]</code> 实际上是 <code class="highlighter-rouge">1:2:3:[]</code> 的语法糖。<code class="highlighter-rouge">[]</code> 表示一个空 List,若要从前端插入 3，它就成了<code class="highlighter-rouge">[3]</code>, 再插入 2，它就成了<code class="highlighter-rouge">[2,3]</code>，以此类推。</p>

<p>一些函数： <br />
<code class="highlighter-rouge">head</code> 返回一个 List 的头部，也就是 List 的首个元素。<br />
<code class="highlighter-rouge">tail</code> 返回一个 List 的尾部，也就是 List 除去头部之后的部分。<br />
<code class="highlighter-rouge">last</code> 返回一个 List 的最后一个元素。<br />
<code class="highlighter-rouge">init</code> 返回一个 List 除去最后一个元素的部分。<br />
<code class="highlighter-rouge">reverse</code> 将一个 List 反转:<br />
<code class="highlighter-rouge">take</code> 返回一个 List 的前几个元素</p>

<h4 id="list-comprehension-列表推导式">List Comprehension 列表推导式</h4>

<p>前十个偶数的 set comprehension 可以表示为<code class="highlighter-rouge">S = {2⋅𝓍 |𝓍 ∈ ℕ,𝓍 ≤ 10 }</code>，竖线左端的部分是输出函数，x 是变量，N 是输入集合，从既有的集合中按照规则产生一个新集合。
在 Haskell 下，我们可以通过类似 take 10 [2,4..] 的代码来实现。但若是把简单的乘 2 改成更复杂的函数操作该怎么办呢？
用 <code class="highlighter-rouge">list comprehension</code>，它与 <code class="highlighter-rouge">set comprehension</code> 十分的相似，用它取前十个偶数轻而易举。这个 <code class="highlighter-rouge">list comprehension</code> 可以表示为：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ghci&gt; [x*2 | x &lt;- [1..10]]
[2,4,6,8,10,12,14,16,18,20]
</code></pre></div></div>

<h4 id="tuple-元组">Tuple 元组</h4>

<ol>
  <li>Tuple 中的项由括号括起，并由逗号隔开。</li>
  <li>要求对需要组合的数据的数目非常的明确。</li>
  <li>它的类型取决于其中项的数目与其各自的类型。</li>
</ol>

<p>考虑一个同时应用到 List 和 Tuple 的问题：如何取得所有三边长度皆为整数且小于等于 10，周长为 24 的直角三角形？</p>

<ol>
  <li>把所有三遍长度小于等于 10 的三角形都列出来。
从三个 List 中取值，并且通过输出函数将其组合为一个三元组</li>
</ol>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let triangles = [ (a,b,c) | c &lt;- [1..10], b &lt;- [1..10], a &lt;- [1..10] ]
</code></pre></div></div>
<p>注意： 三角形 3 条边的关系，<code class="highlighter-rouge">a + b  &gt; c</code></p>

<ol>
  <li>添加一个限制条件，令其必须为直角三角形。同时也考虑上 b 边要短于斜边，a 边要短于 b 边情况：
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let rightTriangles = [ (a,b,c) | c &lt;- [1..10], b &lt;- [1..c], a &lt;- [1..b], a^2 + b^2 == c^2]
</code></pre></div>    </div>
  </li>
  <li>修改函数，告诉它只要周长为 24 的三角形
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let rightTriangles' = [ (a,b,c) | c &lt;- [1..10], b &lt;- [1..c], a &lt;- [1..b], a^2 + b^2 == c^2, a+b+c == 24]
</code></pre></div>    </div>
    <p>调用 函数 <code class="highlighter-rouge">rightTriangles</code></p>
  </li>
</ol>

<p><em>函数式编程语言的一般思路：先取一个初始的集合并将其变形，运行过滤条件，最终取得正确的结果</em></p>

<h3 id="lambda">lambda</h3>

<h3 id="monads">Monads</h3>

<h3 id="函数的合成与柯里化">函数的合成与柯里化</h3>

<p>如果一个值要经过多个函数，才能变成另外一个值，就可以把所有中间步骤合并成一个函数，这叫做”函数的合成”（compose）。</p>

<p><code class="highlighter-rouge">f(x)</code>和<code class="highlighter-rouge">g(x)</code>合成为<code class="highlighter-rouge">f(g(x))</code>，有一个隐藏的前提，就是<code class="highlighter-rouge">f</code>和<code class="highlighter-rouge">g</code>都只能接受一个参数。如果可以接受多个参数，比如<code class="highlighter-rouge">f(x, y)</code>和<code class="highlighter-rouge">g(a, b, c)</code>，函数合成就非常麻烦。
这时就需要函数柯里化了。所谓”柯里化”，就是把一个多参数的函数，转化为单参数函数。</p>

<p>有了柯里化以后，我们就能做到，所有函数只接受一个参数。</p>

<p><em>参考资料</em></p>

<p><a href="http://www.nowamagic.net/academy/detail/1220525">声明式编程范式初探</a><br />
<a href="https://learnyoua.haskell.sg">Haskell 趣学指南</a><br />
<a href="https://www.haskell.org">Haskell官网</a><br />
<a href="http://cnhaskell.com/index.html">real world Haskell</a>  <br />
<a href="http://www.ruanyifeng.com/blog/2017/02/fp-tutorial.html">函数式编程入门教程</a></p>

                </div>
            </section>

            <!-- Email subscribe form at the bottom of the page -->
            <!--   -->
            

            <footer class="post-full-footer">
                <!-- Everything inside the #author tags pulls data from the author -->
                <!-- #author-->
                
                    
                        <section class="author-card">
                            
                                <img class="author-profile-image" src="/assets/images/ghost.png" alt="Miaocf" />
                            
                            <section class="author-card-content">
                                <h4 class="author-card-name"><a href="/author/Miaocf">Miaocf</a></h4>
                                
                                    <p>优秀和极致是两回事</p>
                                
                            </section>
                        </section>
                        <div class="post-full-footer-right">
                            <a class="author-card-button" href="/author/Miaocf">Read More</a>
                        </div>
                    
                
                <!-- /author  -->
            </footer>

            <!-- If you use Disqus comments, just uncomment this block.
            The only thing you need to change is "test-apkdzgmqhj" - which
            should be replaced with your own Disqus site-id. -->
            <div id="gitmentContainer"></div>
<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">
<script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
<script>
var gitment = new Gitment({
    owner: 'JumpJumpSparrow',
    repo: 'My_blog',
    oauth: {
        client_id: '0854e10375734c52272e',
        client_secret: 'e382403bb47cfe33179603e5df7a4c9576ede295',
    },
});
gitment.render('gitmentContainer');
</script>

            

        </article>

    </div>
</main>

<!-- Links to Previous/Next posts -->
<aside class="read-next outer">
    <div class="inner">
        <div class="read-next-feed">
            
                
                
                
                
            

            <!-- If there's a next post, display it using the same markup included from - partials/post-card.hbs -->
            
                

    <article class="post-card post-template">
        
            <a class="post-card-image-link" href="/app-optimize">
                <div class="post-card-image" style="background-image: url(/assets/images/fables.jpg)"></div>
            </a>
        
        <div class="post-card-content">
            <a class="post-card-content-link" href="/app-optimize">
                <header class="post-card-header">
                    
                        
                            
                                <span class="post-card-tags">Ios</span>
                            
                        
                    

                    <h2 class="post-card-title">iOS APP 优化健壮性</h2>
                </header>
                <section class="post-card-excerpt">
                    
                        <p></p>
                    
                </section>
            </a>
            <footer class="post-card-meta">
                
                    
                        
                        <img class="author-profile-image" src="/assets/images/ghost.png" alt="Miaocf" />
                        
                        <span class="post-card-author">
                            <a href="/author/Miaocf/">Miaocf</a>
                        </span>
                    
                
                <span class="reading-time">
                    
                    
                      1 min read
                    
                </span>
            </footer>
        </div>
    </article>

            

            <!-- If there's a previous post, display it using the same markup included from - partials/post-card.hbs -->
            
                

    <article class="post-card post-template">
        
            <a class="post-card-image-link" href="/start">
                <div class="post-card-image" style="background-image: url(/assets/images/car.jpg)"></div>
            </a>
        
        <div class="post-card-content">
            <a class="post-card-content-link" href="/start">
                <header class="post-card-header">
                    
                        
                            
                                <span class="post-card-tags">Getting started</span>
                            
                        
                    

                    <h2 class="post-card-title">Blog Initialized</h2>
                </header>
                <section class="post-card-excerpt">
                    
                        <p></p>
                    
                </section>
            </a>
            <footer class="post-card-meta">
                
                    
                        
                        <img class="author-profile-image" src="/assets/images/ghost.png" alt="Miaocf" />
                        
                        <span class="post-card-author">
                            <a href="/author/Miaocf/">Miaocf</a>
                        </span>
                    
                
                <span class="reading-time">
                    
                    
                      1 min read
                    
                </span>
            </footer>
        </div>
    </article>

            

        </div>
    </div>
</aside>

<!-- Floating header which appears on-scroll, included from includes/floating-header.hbs -->
<div class="floating-header">
    <div class="floating-header-logo">
        <a href="http://localhost:4000/">
            
                <img src="/assets/images/favicon.png" alt="Miaocf icon" />
            
            <span>Miaocf</span>
        </a>
    </div>
    <span class="floating-header-divider">&mdash;</span>
    <div class="floating-header-title">Haskell 函数式编程</div>
    <div class="floating-header-share">
        <div class="floating-header-share-label">Share this <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
    <path d="M7.5 15.5V4a1.5 1.5 0 1 1 3 0v4.5h2a1 1 0 0 1 1 1h2a1 1 0 0 1 1 1H18a1.5 1.5 0 0 1 1.5 1.5v3.099c0 .929-.13 1.854-.385 2.748L17.5 23.5h-9c-1.5-2-5.417-8.673-5.417-8.673a1.2 1.2 0 0 1 1.76-1.605L7.5 15.5zm6-6v2m-3-3.5v3.5m6-1v2"/>
</svg>
</div>
        <a class="floating-header-share-tw" href="https://twitter.com/share?text=Haskell+%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B&amp;url=haskell"
            onclick="window.open(this.href, 'share-twitter', 'width=550,height=235');return false;">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32"><path d="M30.063 7.313c-.813 1.125-1.75 2.125-2.875 2.938v.75c0 1.563-.188 3.125-.688 4.625a15.088 15.088 0 0 1-2.063 4.438c-.875 1.438-2 2.688-3.25 3.813a15.015 15.015 0 0 1-4.625 2.563c-1.813.688-3.75 1-5.75 1-3.25 0-6.188-.875-8.875-2.625.438.063.875.125 1.375.125 2.688 0 5.063-.875 7.188-2.5-1.25 0-2.375-.375-3.375-1.125s-1.688-1.688-2.063-2.875c.438.063.813.125 1.125.125.5 0 1-.063 1.5-.25-1.313-.25-2.438-.938-3.313-1.938a5.673 5.673 0 0 1-1.313-3.688v-.063c.813.438 1.688.688 2.625.688a5.228 5.228 0 0 1-1.875-2c-.5-.875-.688-1.813-.688-2.75 0-1.063.25-2.063.75-2.938 1.438 1.75 3.188 3.188 5.25 4.25s4.313 1.688 6.688 1.813a5.579 5.579 0 0 1 1.5-5.438c1.125-1.125 2.5-1.688 4.125-1.688s3.063.625 4.188 1.813a11.48 11.48 0 0 0 3.688-1.375c-.438 1.375-1.313 2.438-2.563 3.188 1.125-.125 2.188-.438 3.313-.875z"/></svg>

        </a>
        <a class="floating-header-share-fb" href="https://www.facebook.com/sharer/sharer.php?u=haskell"
            onclick="window.open(this.href, 'share-facebook','width=580,height=296');return false;">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32"><path d="M19 6h5V0h-5c-3.86 0-7 3.14-7 7v3H8v6h4v16h6V16h5l1-6h-6V7c0-.542.458-1 1-1z"/></svg>

        </a>
    </div>
    <progress class="progress" value="0">
        <div class="progress-container">
            <span class="progress-bar"></span>
        </div>
    </progress>
</div>


<!-- /post -->

<!-- The #contentFor helper here will send everything inside it up to the matching #block helper found in default.hbs -->


        <!-- Previous/next page links - displayed on every page -->
        

        <!-- The footer at the very bottom of the screen -->
        <footer class="site-footer outer">
            <div class="site-footer-content inner">
                <section class="copyright"><a href="http://localhost:4000/">Miaocf</a> &copy; 2020</section>
                <section class="poweredby">Proudly published with <a href="https://jekyllrb.com/">Jekyll</a> &
                    <a href="https://pages.github.com/" target="_blank" rel="noopener">GitHub Pages</a> using
                    <a href="https://github.com/jekyller/jasper2" target="_blank" rel="noopener">Jasper2</a></section>
                <nav class="site-footer-nav">
                    <a href="/">Latest Posts</a>
                    
                    
                    <a href="https://ghost.org" target="_blank" rel="noopener">Ghost</a>
                </nav>
            </div>
        </footer>

    </div>

    <!-- The big email subscribe modal content -->
    

    <!-- highlight.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.10.0/components/prism-abap.min.js"></script>
    <script>$(document).ready(function() {
      $('pre code').each(function(i, block) {
        hljs.highlightBlock(block);
      });
    });</script>

    <!-- jQuery + Fitvids, which makes all video embeds responsive -->
    <script
        src="https://code.jquery.com/jquery-3.2.1.min.js"
        integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4="
        crossorigin="anonymous">
    </script>
    <script type="text/javascript" src="/assets/js/jquery.fitvids.js"></script>
    <script type="text/javascript" src="https://demo.ghost.io/assets/js/jquery.fitvids.js?v=724281a32e"></script>


    <!-- Paginator increased to "infinit" in _config.yml -->
    <!-- if paginator.posts  -->
    <!-- <script>
        var maxPages = parseInt('');
    </script>
    <script src="/assets/js/infinitescroll.js"></script> -->
    <!-- /endif -->

    


    <!-- Add Baidu Analytics  -->
    <!-- Baidu Analytics Tracking code -->
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?189baef3a30b22e9e158be16b3016a58";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



    <!-- The #block helper will pull in data from the #contentFor other template files. In this case, there's some JavaScript which we only want to use in post.hbs, but it needs to be included down here, after jQuery has already loaded. -->
    
        <script>

// NOTE: Scroll performance is poor in Safari
// - this appears to be due to the events firing much more slowly in Safari.
//   Dropping the scroll event and using only a raf loop results in smoother
//   scrolling but continuous processing even when not scrolling
$(document).ready(function () {
    // Start fitVids
    var $postContent = $(".post-full-content");
    $postContent.fitVids();
    // End fitVids

    var progressBar = document.querySelector('progress');
    var header = document.querySelector('.floating-header');
    var title = document.querySelector('.post-full-title');

    var lastScrollY = window.scrollY;
    var lastWindowHeight = window.innerHeight;
    var lastDocumentHeight = $(document).height();
    var ticking = false;

    function onScroll() {
        lastScrollY = window.scrollY;
        requestTick();
    }

    function onResize() {
        lastWindowHeight = window.innerHeight;
        lastDocumentHeight = $(document).height();
        requestTick();
    }

    function requestTick() {
        if (!ticking) {
            requestAnimationFrame(update);
        }
        ticking = true;
    }

    function update() {
        var trigger = title.getBoundingClientRect().top + window.scrollY;
        var triggerOffset = title.offsetHeight + 35;
        var progressMax = lastDocumentHeight - lastWindowHeight;

        // show/hide floating header
        if (lastScrollY >= trigger + triggerOffset) {
            header.classList.add('floating-active');
        } else {
            header.classList.remove('floating-active');
        }

        progressBar.setAttribute('max', progressMax);
        progressBar.setAttribute('value', lastScrollY);

        ticking = false;
    }

    window.addEventListener('scroll', onScroll, {passive: true});
    window.addEventListener('resize', onResize, false);

    update();
});
</script>

    

    <!-- Ghost outputs important scripts and data with this tag - it should always be the very last thing before the closing body tag -->
    <!-- ghost_foot -->

</body>
</html>
